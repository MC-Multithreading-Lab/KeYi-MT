From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: BuildTools <unconfigured@null.spigotmc.org>
Date: Sat, 21 Jan 2023 16:33:45 +0800
Subject: [PATCH] Some multithread patches


diff --git a/src/main/java/cc/keyimc/keyi/concurrent/WorkerThread.java b/src/main/java/cc/keyimc/keyi/concurrent/WorkerThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..27d6c4a7cc2f13dfcd8f0bb694baeb512db8ef78
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/concurrent/WorkerThread.java
@@ -0,0 +1,18 @@
+package cc.keyimc.keyi.concurrent;
+
+import io.papermc.paper.util.TickThread;
+
+public class WorkerThread extends TickThread {
+
+    public WorkerThread(String name) {
+        super(name);
+    }
+
+    public WorkerThread(Runnable run, String name) {
+        super(run, name);
+    }
+
+    public static boolean isWorker(){
+        return Thread.currentThread() instanceof WorkerThread;
+    }
+}
diff --git a/src/main/java/cc/keyimc/keyi/concurrent/WorkerThreadFactory.java b/src/main/java/cc/keyimc/keyi/concurrent/WorkerThreadFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..17c2a90fca16e90ed2435bbc40c149c62bd8cb37
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/concurrent/WorkerThreadFactory.java
@@ -0,0 +1,5 @@
+package cc.keyimc.keyi.concurrent;
+
+public interface WorkerThreadFactory {
+    WorkerThread getNewThread(Runnable task);
+}
diff --git a/src/main/java/cc/keyimc/keyi/concurrent/WorkerThreadPoolExecutor.java b/src/main/java/cc/keyimc/keyi/concurrent/WorkerThreadPoolExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0dbdc5390570c42014fd1e62ec2afa2c207e09c
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/concurrent/WorkerThreadPoolExecutor.java
@@ -0,0 +1,76 @@
+package cc.keyimc.keyi.concurrent;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Queue;
+import java.util.concurrent.*;
+import java.util.concurrent.locks.LockSupport;
+
+public class WorkerThreadPoolExecutor extends ThreadPoolExecutor {
+    private final Queue<TaskEntry> taskEntries = new ConcurrentLinkedQueue<>();
+
+    public WorkerThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, @NotNull TimeUnit unit, @NotNull BlockingQueue<Runnable> workQueue, @NotNull WorkerThreadFactory workerThreadFactory) {
+        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, workerThreadFactory::getNewThread);
+    }
+
+    public WorkerThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, @NotNull TimeUnit unit, @NotNull BlockingQueue<Runnable> workQueue, @NotNull WorkerThreadFactory workerThreadFactory, @NotNull RejectedExecutionHandler handler) {
+        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, workerThreadFactory::getNewThread, handler);
+    }
+
+    public int getCurrentNotProcessingTasks(){
+        return this.getQueue().size();
+    }
+
+    public void clearAllTasks(){
+        this.getQueue().clear();
+    }
+
+    public void executeWithSubTask(Runnable mainTask,Runnable subTask){
+        final TaskEntry wrapped = new TaskEntry(subTask,mainTask);
+        this.taskEntries.offer(wrapped);
+        this.execute(wrapped);
+    }
+
+    public void runAllSubTasks(){
+        TaskEntry task;
+        while ((task = this.taskEntries.poll())!=null){
+            while (!task.allRunned()){
+                LockSupport.parkNanos(this,10000000);
+            }
+        }
+    }
+
+    private static class TaskEntry implements Runnable{
+        private final Runnable mainTask;
+        private final Runnable subTask;
+        private volatile boolean mainTaskFinished = false;
+
+        public TaskEntry(Runnable subTask,Runnable mainTask){
+            this.subTask = subTask;
+            this.mainTask = mainTask;
+        }
+
+        public boolean allRunned(){
+            if (!this.mainTaskFinished){
+                return false;
+            }
+            try {
+                this.subTask.run();
+            }catch (Exception e){
+                e.printStackTrace();
+            }
+            return true;
+        }
+
+        @Override
+        public void run() {
+            try {
+                this.mainTask.run();
+            }catch(Exception e){
+                e.printStackTrace();
+            }finally {
+                this.mainTaskFinished = true;
+            }
+        }
+    }
+}
diff --git a/src/main/java/cc/keyimc/keyi/concurrent/thread/Worker.java b/src/main/java/cc/keyimc/keyi/concurrent/thread/Worker.java
new file mode 100644
index 0000000000000000000000000000000000000000..ae710854e52591b32fe547f0f1c6675731bffcb6
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/concurrent/thread/Worker.java
@@ -0,0 +1,7 @@
+package cc.keyimc.keyi.concurrent.thread;
+
+public interface Worker {
+    static boolean isWorker(){
+        return Thread.currentThread() instanceof Worker;
+    }
+}
diff --git a/src/main/java/cc/keyimc/keyi/concurrent/thread/WorkerForkJoinThread.java b/src/main/java/cc/keyimc/keyi/concurrent/thread/WorkerForkJoinThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..d41fe055fd0a164c553da742044ebe4c17c6b657
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/concurrent/thread/WorkerForkJoinThread.java
@@ -0,0 +1,10 @@
+package cc.keyimc.keyi.concurrent.thread;
+
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinWorkerThread;
+
+public class WorkerForkJoinThread extends ForkJoinWorkerThread implements Worker {
+    protected WorkerForkJoinThread(ForkJoinPool pool) {
+        super(pool);
+    }
+}
diff --git a/src/main/java/cc/keyimc/keyi/concurrent/thread/WorkerThread.java b/src/main/java/cc/keyimc/keyi/concurrent/thread/WorkerThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..81a607b0d1cad739b7dc284b87877243d9c86520
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/concurrent/thread/WorkerThread.java
@@ -0,0 +1,14 @@
+package cc.keyimc.keyi.concurrent.thread;
+
+import io.papermc.paper.util.TickThread;
+
+public class WorkerThread extends TickThread implements Worker{
+
+    public WorkerThread(String name) {
+        super(name);
+    }
+
+    public WorkerThread(Runnable run, String name) {
+        super(run, name);
+    }
+}
diff --git a/src/main/java/cc/keyimc/keyi/concurrent/threadfactory/DefaultWorkerFactory.java b/src/main/java/cc/keyimc/keyi/concurrent/threadfactory/DefaultWorkerFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..3bcdc7f95c110424f008084e0bfb1990dd801002
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/concurrent/threadfactory/DefaultWorkerFactory.java
@@ -0,0 +1,42 @@
+package cc.keyimc.keyi.concurrent.threadfactory;
+
+import cc.keyimc.keyi.concurrent.WorkerThread;
+import cc.keyimc.keyi.concurrent.WorkerThreadFactory;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectLists;
+import net.minecraft.server.MinecraftServer;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class DefaultWorkerFactory implements WorkerThreadFactory {
+    private static final AtomicInteger poolId = new AtomicInteger();
+    private final AtomicInteger threadId = new AtomicInteger();
+    private final String bound;
+    private final List<Thread> createdThreads = ObjectLists.synchronize(new ObjectArrayList<>());
+
+    public DefaultWorkerFactory(String bound){
+        poolId.getAndIncrement();
+        this.bound = bound;
+    }
+
+    public List<Thread> getCreatedThreads() {
+        return this.createdThreads;
+    }
+
+    @Override
+    public WorkerThread getNewThread(Runnable task) {
+        final WorkerThread workerThread = new WorkerThread(()->{
+            try {
+                task.run();
+            }finally {
+                this.createdThreads.remove(Thread.currentThread());
+            }
+        },"pool-"+poolId.get()+"-worker-"+threadId.getAndIncrement()+"-bound-"+this.bound);
+        this.createdThreads.add(workerThread);
+        workerThread.setDaemon(true);
+        workerThread.setPriority(Thread.NORM_PRIORITY - 2);
+        workerThread.setContextClassLoader(MinecraftServer.class.getClassLoader());
+        return workerThread;
+    }
+}
diff --git a/src/main/java/cc/keyimc/keyi/config/KGlobalConfig.java b/src/main/java/cc/keyimc/keyi/config/KGlobalConfig.java
index ed2d911f5393abb6c398c909c4667867034aaf87..57dea90862268145967f11c9eda5e1b5fab31bcb 100644
--- a/src/main/java/cc/keyimc/keyi/config/KGlobalConfig.java
+++ b/src/main/java/cc/keyimc/keyi/config/KGlobalConfig.java
@@ -74,6 +74,14 @@ public class KGlobalConfig {
     public boolean offlineModeWarning = true;
     public boolean proxyUnsafeWarning = true;
 
+    //Optimizations
+    public boolean parallelEntity = false;
+    public boolean parallelWorld = true;
+    public boolean multiThreadTracker = true;
+    public int multiThreadTrackerThreadCount = Math.max(Runtime.getRuntime().availableProcessors()/2,2);
+    public int parallelEntityThreadCount = Runtime.getRuntime().availableProcessors();
+    public boolean awaitParallelEntity = true;
+
     private void initValues() {
         verbose = get("verbose", verbose);
         version = get("dont-touch-these-values-down-below.version", version);
@@ -94,6 +102,16 @@ public class KGlobalConfig {
         offlineModeWarning = get("misc.offline-mode-warning", offlineModeWarning);
         proxyUnsafeWarning = get("misc.proxy-unsafe-warning", proxyUnsafeWarning);
 
+        //Optimizations
+        parallelEntity = get("optimizations.enable-parallel-entity",parallelEntity);
+        parallelWorld = get("optimizations.enable-parallel-world",parallelWorld);
+        multiThreadTracker = get("optimizations.enable-multithreaded-tracker",multiThreadTracker);
+
+        multiThreadTrackerThreadCount = get("optimizations.multithread-tracker-thread-count",multiThreadTrackerThreadCount);
+        parallelEntityThreadCount = get("optimizations.parallel-entity-thread-count",parallelEntityThreadCount);
+
+        awaitParallelEntity = get("debug.await-parallel-entity-tasks",awaitParallelEntity);
+
         initComments();
     }
 
diff --git a/src/main/java/cc/keyimc/keyi/server/PublicConstants.java b/src/main/java/cc/keyimc/keyi/server/PublicConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..9835262ab83ac4972ec75ef125df5d135ed35ca0
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/server/PublicConstants.java
@@ -0,0 +1,7 @@
+package cc.keyimc.keyi.server;
+
+import cc.keyimc.keyi.workers.WorkerThreadPoolManager;
+
+public class PublicConstants {
+    public static WorkerThreadPoolManager WORKER_MANAGER = new WorkerThreadPoolManager();
+}
diff --git a/src/main/java/cc/keyimc/keyi/server/ServerEntityTickHook.java b/src/main/java/cc/keyimc/keyi/server/ServerEntityTickHook.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7b92919eb6402389ec51410565592a7be360bd3
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/server/ServerEntityTickHook.java
@@ -0,0 +1,95 @@
+package cc.keyimc.keyi.server;
+
+import cc.keyimc.keyi.concurrent.WorkerThreadFactory;
+import cc.keyimc.keyi.concurrent.WorkerThreadPoolExecutor;
+import cc.keyimc.keyi.concurrent.threadfactory.DefaultWorkerFactory;
+import cc.keyimc.keyi.config.KGlobalConfig;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.LockSupport;
+
+public class ServerEntityTickHook {
+    private static final Logger logger = LogManager.getLogger();
+    private static final WorkerThreadFactory defFactory = new DefaultWorkerFactory("entity");
+    private static WorkerThreadPoolExecutor worker;
+    private static boolean asyncEntityEnabled = true;
+    private static boolean awaitEntityTasks = true;
+    private static final AtomicInteger taskCounter = new AtomicInteger(0);
+
+    //To prevent the chunk system error.This is necessary
+    public static void awaitEntityTasks(){
+        if (awaitEntityTasks){
+            return;
+        }
+        while (taskCounter.get() > 0){
+            LockSupport.parkNanos("Await entities",1000000);
+        }
+    }
+
+    public static void init(){
+        awaitEntityTasks = KGlobalConfig.getInstance().awaitParallelEntity;
+        asyncEntityEnabled = KGlobalConfig.getInstance().parallelEntity;
+        final int workerCount = KGlobalConfig.getInstance().parallelEntityThreadCount;
+        if (asyncEntityEnabled){
+            worker = new WorkerThreadPoolExecutor(
+                    workerCount,
+                    workerCount,
+                    0L,
+                    TimeUnit.MILLISECONDS,
+                    new LinkedBlockingQueue<>(),
+                    defFactory
+            );
+            PublicConstants.WORKER_MANAGER.addWorker("entity",worker);
+        }
+
+    }
+
+
+    public static void callAsyncEntityTick(Entity entity, ServerLevel level){
+        MinecraftServer.getServer().executeMidTickTasks();
+        taskCounter.getAndIncrement();
+        Runnable task = ()->{
+            try {
+                entity.activatedPriorityReset = false;
+                if (!entity.isRemoved()) {
+                    entity.checkDespawn();
+                    Entity entity1 = entity.getVehicle();
+                    if (entity1 != null) {
+                        if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
+                            return;
+                        }
+                        entity.stopRiding();
+                    }
+                    try {
+                        level.tickNonPassenger(entity);
+                    } catch (Throwable throwable) {
+                        if (throwable instanceof ThreadDeath) throw throwable;
+                        level.getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(throwable.getMessage(), throwable)));
+                        throwable.printStackTrace();
+                    }
+                }
+            }finally {
+                taskCounter.getAndDecrement();
+            }
+        };
+
+        if (!asyncEntityEnabled){
+            task.run();
+            return;
+        }
+
+        try {
+            worker.execute(task);
+        }catch (RejectedExecutionException e){
+            logger.warn("Worker rejected our task.Falling back to sync entity updating");
+            asyncEntityEnabled = false;
+        }
+    }
+}
diff --git a/src/main/java/cc/keyimc/keyi/server/ServerLevelTickHook.java b/src/main/java/cc/keyimc/keyi/server/ServerLevelTickHook.java
new file mode 100644
index 0000000000000000000000000000000000000000..6e57a1633759ea38248b2868f9087fc6a12e4b76
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/server/ServerLevelTickHook.java
@@ -0,0 +1,77 @@
+package cc.keyimc.keyi.server;
+
+import cc.keyimc.keyi.concurrent.WorkerThreadPoolExecutor;
+import cc.keyimc.keyi.concurrent.threadfactory.DefaultWorkerFactory;
+import cc.keyimc.keyi.config.KGlobalConfig;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.LockSupport;
+import java.util.function.BooleanSupplier;
+
+public class ServerLevelTickHook {
+    private static final DefaultWorkerFactory workerFactory = new DefaultWorkerFactory("world");
+    private static WorkerThreadPoolExecutor worker;
+    private static boolean enabledParaWorld;
+    private static final AtomicInteger activeTaskCount = new AtomicInteger();
+    private static final Logger logger = LogManager.getLogger();
+
+    public static void init(){
+        enabledParaWorld = KGlobalConfig.getInstance().parallelWorld;
+        if (enabledParaWorld){
+            worker = new WorkerThreadPoolExecutor(
+                    MinecraftServer.getServer().levels.size(),
+                    MinecraftServer.getServer().levels.size(),
+                    Long.MAX_VALUE,
+                    TimeUnit.MILLISECONDS,
+                    new LinkedBlockingQueue<>(),
+                    workerFactory
+            );
+            worker.allowCoreThreadTimeOut(true);
+            worker.prestartAllCoreThreads();
+            PublicConstants.WORKER_MANAGER.addWorker("world",worker);
+            for (Thread worker : workerFactory.getCreatedThreads()){
+                logger.warn("World worker name:{}.This can help you to slove the lag problems when you using parallel world ticking",worker.getName());
+            }
+        }
+    }
+
+    public static void callWorldTick(ServerLevel worldserver, BooleanSupplier shouldKeepTicking){
+        activeTaskCount.getAndIncrement();
+        Runnable task = ()->{
+            try {
+                try {
+                    worldserver.tick(shouldKeepTicking);
+                    for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
+                        regionManager.recalculateRegions();
+                    }
+                } catch (Throwable throwable) {
+                    throwable.printStackTrace();
+                }
+                worldserver.explosionDensityCache.clear();
+            }finally {
+                activeTaskCount.getAndDecrement();
+            }
+        };
+
+        if (!enabledParaWorld){
+            task.run();
+            return;
+        }
+
+        worker.execute(task);
+    }
+
+    public static void awaitWorldTicKTasks(){
+        if (!enabledParaWorld){
+            return;
+        }
+        while (activeTaskCount.get() > 0){
+            LockSupport.parkNanos("Await world ticking",1000000);
+        }
+    }
+}
diff --git a/src/main/java/cc/keyimc/keyi/utils/ArrayListBlockingQueue.java b/src/main/java/cc/keyimc/keyi/utils/ArrayListBlockingQueue.java
new file mode 100644
index 0000000000000000000000000000000000000000..25c72579acbdd33c80cc912865158062b869ea2a
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/utils/ArrayListBlockingQueue.java
@@ -0,0 +1,256 @@
+package cc.keyimc.keyi.utils;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.locks.*;
+
+public class ArrayListBlockingQueue<T> implements BlockingQueue<T> {
+    private final List<T> internalList = new ArrayList<>();
+    private final StampedLock editLock = new StampedLock();
+
+    @Override
+    public boolean add(@NotNull T t) {
+        final long id = this.editLock.writeLock();
+        try {
+            return this.internalList.add(t);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public boolean offer(@NotNull T t) {
+        final long id = this.editLock.writeLock();
+        try {
+            return this.internalList.add(t);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public T remove() {
+        final long id = this.editLock.writeLock();
+        try {
+            return this.internalList.remove(0);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public T poll() {
+        final long id = this.editLock.writeLock();
+        try {
+            return this.internalList.isEmpty() ? null : this.internalList.remove(0);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public T element() {
+        long id = this.editLock.readLock();
+        try {
+            if (this.internalList.isEmpty()){
+                throw new NoSuchElementException();
+            }
+            return this.internalList.get(0);
+        }finally {
+            this.editLock.unlockRead(id);
+        }
+    }
+
+    @Override
+    public T peek() {
+        long id = this.editLock.readLock();
+        try {
+            if (this.internalList.isEmpty()){
+                throw new NoSuchElementException();
+            }
+            return this.internalList.get(0);
+        }finally {
+            this.editLock.unlockRead(id);
+        }
+    }
+
+    @Override
+    public void put(@NotNull T t) {
+        final long id = this.editLock.writeLock();
+        try {
+            this.internalList.add(t);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public boolean offer(T t, long timeout, @NotNull TimeUnit unit) {
+        final long id = this.editLock.writeLock();
+        try {
+            return this.internalList.add(t);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public T take() throws InterruptedException {
+        T t;
+        while ((t = this.poll()) == null){
+            synchronized (this){
+                this.wait(0,1);
+            }
+        }
+        return t;
+    }
+
+    @Override
+    public T poll(long timeout, @NotNull TimeUnit unit) throws InterruptedException {
+        T t;
+        long countTime = unit.toNanos(timeout);
+        while ((t = this.poll()) == null){
+            if (countTime == 0){
+                break;
+            }
+            synchronized (this){
+                this.wait(0,1);
+            }
+            countTime--;
+        }
+        return t;
+    }
+
+    @Override
+    public int remainingCapacity() {
+        throw new UnsupportedOperationException("remainingCapacity");
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        final long id = this.editLock.writeLock();
+        try {
+            return this.internalList.remove(o);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> c) {
+        final long id = this.editLock.writeLock();
+        try {
+            return new HashSet<>(this.internalList).containsAll(c);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends T> c) {
+        final long id = this.editLock.writeLock();
+        try {
+            return this.internalList.addAll(c);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> c) {
+        final long id = this.editLock.writeLock();
+        try {
+            return this.internalList.removeAll(c);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> c) {
+        final long id = this.editLock.writeLock();
+        try {
+            return this.internalList.retainAll(c);
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public void clear() {
+        final long id = this.editLock.writeLock();
+        try {
+            this.internalList.clear();
+        }finally {
+            this.editLock.unlockWrite(id);
+        }
+    }
+
+    @Override
+    public int size() {
+        long id = this.editLock.readLock();
+        try {
+            return this.internalList.size();
+        }finally {
+            this.editLock.unlockRead(id);
+        }
+    }
+
+    @Override
+    public boolean isEmpty() {
+        long id = this.editLock.readLock();
+        try {
+            return this.internalList.isEmpty();
+        }finally {
+            this.editLock.unlockRead(id);
+        }
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        long id = this.editLock.readLock();
+        try {
+            return this.internalList.contains(o);
+        }finally {
+            this.editLock.unlockRead(id);
+        }
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        throw new UnsupportedOperationException("Iterator");
+    }
+
+    @Override
+    public Object[] toArray() {
+        long id = this.editLock.readLock();
+        try {
+            return this.internalList.toArray();
+        }finally {
+            this.editLock.unlockRead(id);
+        }
+    }
+
+    @Override
+    public <T1> T1[] toArray(T1 @NotNull [] a) {
+        long id = this.editLock.readLock();
+        try {
+            return this.internalList.toArray(a);
+        }finally {
+            this.editLock.unlockRead(id);
+        }
+    }
+
+    @Override
+    public int drainTo(@NotNull Collection<? super T> c) {
+        throw new UnsupportedOperationException("drainTo");
+    }
+
+    @Override
+    public int drainTo(@NotNull Collection<? super T> c, int maxElements) {
+        throw new UnsupportedOperationException("drainTo");
+    }
+}
+
diff --git a/src/main/java/cc/keyimc/keyi/utils/EntityPositionCache.java b/src/main/java/cc/keyimc/keyi/utils/EntityPositionCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..8185ec552e7e885a46896e3b7a3fbabcb5061e09
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/utils/EntityPositionCache.java
@@ -0,0 +1,60 @@
+package cc.keyimc.keyi.utils;
+
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.phys.Vec3;
+import org.jetbrains.annotations.NotNull;
+
+public class EntityPositionCache {
+    private final double x;
+    private final double y;
+    private final double z;
+    private final LivingEntity currentEntity;
+
+    public EntityPositionCache(@NotNull LivingEntity entity){
+        this.x = entity.getX();
+        this.y = entity.getY();
+        this.z = entity.getZ();
+        this.currentEntity = entity;
+    }
+
+    public LivingEntity getCurrentEntity() {
+        return this.currentEntity;
+    }
+
+    public double getX() {
+        return this.x;
+    }
+
+    public double getY() {
+        return this.y;
+    }
+
+    public double getZ() {
+        return this.z;
+    }
+
+    public double distanceToSqr(double x, double y, double z) {
+        double d3 = this.x - x;
+        double d4 = this.y - y;
+        double d5 = this.z - z;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double distanceToSqr(Entity entity) {
+        return this.distanceToSqr(entity.position());
+    }
+
+    public double distanceToSqr(Vec3 vector) {
+        double d0 = this.x - vector.x;
+        double d1 = this.y - vector.y;
+        double d2 = this.z - vector.z;
+
+        return d0 * d0 + d1 * d1 + d2 * d2;
+    }
+
+    public double distanceToSqr(EntityPositionCache entityPositionCache) {
+        return this.distanceToSqr(entityPositionCache.getX(),entityPositionCache.getY(),entityPositionCache.getZ());
+    }
+}
diff --git a/src/main/java/cc/keyimc/keyi/workers/WorkerThreadPoolManager.java b/src/main/java/cc/keyimc/keyi/workers/WorkerThreadPoolManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a4c5ca742502e6893b586ad29ae2c71c914ecf4
--- /dev/null
+++ b/src/main/java/cc/keyimc/keyi/workers/WorkerThreadPoolManager.java
@@ -0,0 +1,68 @@
+package cc.keyimc.keyi.workers;
+
+import cc.keyimc.keyi.concurrent.WorkerThreadPoolExecutor;
+import com.google.common.collect.Maps;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+public class WorkerThreadPoolManager {
+    private final Map<String,WorkerThreadPoolExecutor> managedWorkers = Maps.newConcurrentMap();
+
+    public void addWorker(String bound,WorkerThreadPoolExecutor worker){
+        this.managedWorkers.put(bound,worker);
+    }
+
+    public void shutdownAll() throws InterruptedException {
+        for (WorkerThreadPoolExecutor worker : this.managedWorkers.values()){
+            if (!worker.isShutdown()){
+                worker.getQueue().clear(); //Clear the tasks.We don't need wait them
+                worker.shutdown();
+                while (worker.awaitTermination(100, TimeUnit.MILLISECONDS)) {}
+            }
+        }
+    }
+
+    @Deprecated
+    public Map<String, WorkerThreadPoolExecutor> getManagedWorkers() {
+        return Maps.newHashMap(this.managedWorkers);
+    }
+
+    @Deprecated
+    public WorkerThreadPoolExecutor getTargetWorker(String bound){
+        return this.managedWorkers.get(bound);
+    }
+
+    public Map<String,List<Runnable>> shutdownAllNow(){
+        final Map<String,List<Runnable>> ret = Maps.newHashMap();
+        for (Map.Entry<String,WorkerThreadPoolExecutor> entry : this.managedWorkers.entrySet()){
+            final String workerName = entry.getKey();
+            final WorkerThreadPoolExecutor worker = entry.getValue();
+            if (!worker.isShutdown()){
+                try {
+                    final List<Runnable> taskNotRunned = worker.shutdownNow();
+                    ret.put(workerName,taskNotRunned);
+                }catch (Exception e){
+                    e.printStackTrace();
+                }
+            }
+        }
+        return ret;
+    }
+
+    public void shutdownAll(long singleWorkerAwaitTimeOutCount) throws InterruptedException {
+        long counter = singleWorkerAwaitTimeOutCount;
+        for (WorkerThreadPoolExecutor worker : this.managedWorkers.values()){
+            if (!worker.isShutdown()){
+                worker.shutdown();
+                while (worker.awaitTermination(1, TimeUnit.MILLISECONDS)) {
+                    if (counter == 0){
+                        break;
+                    }
+                    counter--;
+                }
+                counter = singleWorkerAwaitTimeOutCount;
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
index 0133ea6feb1ab88f021f66855669f58367e7420b..a1ac254c71eb5559b88ed1a6bd5128539d3b38b5 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
@@ -1,128 +1,50 @@
 package com.destroystokyo.paper.util.maplist;
 
-import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectList;
+import it.unimi.dsi.fastutil.objects.ObjectLists;
 import net.minecraft.world.entity.Entity;
-import java.util.Arrays;
+import org.jetbrains.annotations.NotNull;
+
 import java.util.Iterator;
-import java.util.NoSuchElementException;
 
-// list with O(1) remove & contains
-/**
- * @author Spottedleaf
- */
 public final class EntityList implements Iterable<Entity> {
-
-    protected final Int2IntOpenHashMap entityToIndex = new Int2IntOpenHashMap(2, 0.8f);
-    {
-        this.entityToIndex.defaultReturnValue(Integer.MIN_VALUE);
-    }
-
-    protected static final Entity[] EMPTY_LIST = new Entity[0];
-
-    protected Entity[] entities = EMPTY_LIST;
-    protected int count;
+    private final ObjectList<Entity> entities = ObjectLists.synchronize(new ObjectArrayList<>());
 
     public int size() {
-        return this.count;
+        return this.entities.size();
     }
 
     public boolean contains(final Entity entity) {
-        return this.entityToIndex.containsKey(entity.getId());
+        return this.entities.contains(entity);
     }
 
     public boolean remove(final Entity entity) {
-        final int index = this.entityToIndex.remove(entity.getId());
-        if (index == Integer.MIN_VALUE) {
-            return false;
-        }
-
-        // move the entity at the end to this index
-        final int endIndex = --this.count;
-        final Entity end = this.entities[endIndex];
-        if (index != endIndex) {
-            // not empty after this call
-            this.entityToIndex.put(end.getId(), index); // update index
-        }
-        this.entities[index] = end;
-        this.entities[endIndex] = null;
-
-        return true;
+        return this.entities.remove(entity);
     }
 
     public boolean add(final Entity entity) {
-        final int count = this.count;
-        final int currIndex = this.entityToIndex.putIfAbsent(entity.getId(), count);
-
-        if (currIndex != Integer.MIN_VALUE) {
-            return false; // already in this list
-        }
-
-        Entity[] list = this.entities;
-
-        if (list.length == count) {
-            // resize required
-            list = this.entities = Arrays.copyOf(list, (int)Math.max(4L, count * 2L)); // overflow results in negative
-        }
-
-        list[count] = entity;
-        this.count = count + 1;
-
-        return true;
+        return this.entities.add(entity);
     }
 
     public Entity getChecked(final int index) {
-        if (index < 0 || index >= this.count) {
-            throw new IndexOutOfBoundsException("Index: " + index + " is out of bounds, size: " + this.count);
-        }
-        return this.entities[index];
+        return this.entities.get(index);
     }
 
     public Entity getUnchecked(final int index) {
-        return this.entities[index];
+        return this.entities.get(index);
     }
 
     public Entity[] getRawData() {
-        return this.entities;
+        return this.entities.toArray(Entity[]::new);
     }
 
     public void clear() {
-        this.entityToIndex.clear();
-        Arrays.fill(this.entities, 0, this.count, null);
-        this.count = 0;
+        this.entities.clear();
     }
 
     @Override
-    public Iterator<Entity> iterator() {
-        return new Iterator<Entity>() {
-
-            Entity lastRet;
-            int current;
-
-            @Override
-            public boolean hasNext() {
-                return this.current < EntityList.this.count;
-            }
-
-            @Override
-            public Entity next() {
-                if (this.current >= EntityList.this.count) {
-                    throw new NoSuchElementException();
-                }
-                return this.lastRet = EntityList.this.entities[this.current++];
-            }
-
-            @Override
-            public void remove() {
-                final Entity lastRet = this.lastRet;
-
-                if (lastRet == null) {
-                    throw new IllegalStateException();
-                }
-                this.lastRet = null;
-
-                EntityList.this.remove(lastRet);
-                --this.current;
-            }
-        };
+    public @NotNull Iterator<Entity> iterator() {
+        return this.entities.iterator();
     }
 }
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
index 277cfd9d1e8fff5d9b5e534b75c3c5162d58b0b7..07247f11b079bfb631010ff06fe353d3dcc0a0f6 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
@@ -53,7 +53,7 @@ public final class IBlockDataList {
         return this.add(getLocationKey(x, y, z), data);
     }
 
-    public long add(final int location, final BlockState data) {
+    public synchronized long add(final int location, final BlockState data) {
         final long curr = this.map.get((short)location);
 
         if (curr == Long.MAX_VALUE) {
@@ -81,7 +81,7 @@ public final class IBlockDataList {
         return this.remove(getLocationKey(x, y, z));
     }
 
-    public long remove(final int location) {
+    public synchronized long remove(final int location) {
         final long ret = this.map.remove((short)location);
         final int index = getIndexFromRaw(ret);
         if (ret == Long.MAX_VALUE) {
@@ -101,11 +101,11 @@ public final class IBlockDataList {
         return ret;
     }
 
-    public int size() {
+    public synchronized int size() {
         return this.size;
     }
 
-    public long getRaw(final int index) {
+    public synchronized long getRaw(final int index) {
         return this.byIndex[index];
     }
 
@@ -117,12 +117,12 @@ public final class IBlockDataList {
         return getBlockDataFromRaw(this.getRaw(index));
     }
 
-    public void clear() {
+    public synchronized void clear() {
         this.size = 0;
         this.map.clear();
     }
 
-    public LongIterator getRawIterator() {
+    public synchronized LongIterator getRawIterator() {
         return this.map.values().iterator();
     }
 }
diff --git a/src/main/java/com/destroystokyo/paper/util/set/OptimizedSmallEnumSet.java b/src/main/java/com/destroystokyo/paper/util/set/OptimizedSmallEnumSet.java
index b3329c6fcd6758a781a51f5ba8f5052ac1c77b49..adb02cba6cdb62752f847136000c6f7ca857bd5a 100644
--- a/src/main/java/com/destroystokyo/paper/util/set/OptimizedSmallEnumSet.java
+++ b/src/main/java/com/destroystokyo/paper/util/set/OptimizedSmallEnumSet.java
@@ -2,9 +2,6 @@ package com.destroystokyo.paper.util.set;
 
 import java.util.Collection;
 
-/**
- * @author Spottedleaf <Spottedleaf@users.noreply.github.com>
- */
 public final class OptimizedSmallEnumSet<E extends Enum<E>> {
 
     private final Class<E> enumClass;
@@ -20,7 +17,7 @@ public final class OptimizedSmallEnumSet<E extends Enum<E>> {
         this.enumClass = clazz;
     }
 
-    public boolean addUnchecked(final E element) {
+    public synchronized boolean addUnchecked(final E element) {
         final int ordinal = element.ordinal();
         final long key = 1L << ordinal;
 
@@ -30,7 +27,7 @@ public final class OptimizedSmallEnumSet<E extends Enum<E>> {
         return (prev & key) == 0;
     }
 
-    public boolean removeUnchecked(final E element) {
+    public synchronized boolean removeUnchecked(final E element) {
         final int ordinal = element.ordinal();
         final long key = 1L << ordinal;
 
@@ -40,15 +37,15 @@ public final class OptimizedSmallEnumSet<E extends Enum<E>> {
         return (prev & key) != 0;
     }
 
-    public void clear() {
+    public synchronized void clear() {
         this.backingSet = 0L;
     }
 
-    public int size() {
+    public synchronized int size() {
         return Long.bitCount(this.backingSet);
     }
 
-    public void addAllUnchecked(final Collection<E> enums) {
+    public synchronized void addAllUnchecked(final Collection<E> enums) {
         for (final E element : enums) {
             if (element == null) {
                 throw new NullPointerException("Null element");
@@ -57,15 +54,15 @@ public final class OptimizedSmallEnumSet<E extends Enum<E>> {
         }
     }
 
-    public long getBackingSet() {
+    public synchronized long getBackingSet() {
         return this.backingSet;
     }
 
-    public boolean hasCommonElements(final OptimizedSmallEnumSet<E> other) {
+    public synchronized boolean hasCommonElements(final OptimizedSmallEnumSet<E> other) {
         return (other.backingSet & this.backingSet) != 0;
     }
 
-    public boolean hasElement(final E element) {
+    public synchronized boolean hasElement(final E element) {
         return (this.backingSet & (1L << element.ordinal())) != 0;
     }
 }
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 0b060183429f4c72ec767075538477b4302bbf0d..d9cee42da1b097590e627142d3c5dccbc180b5ae 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -7,9 +7,9 @@ import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.IntervalledCounter;
 import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
-import it.unimi.dsi.fastutil.objects.Reference2ObjectLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.longs.LongSets;
+import it.unimi.dsi.fastutil.objects.*;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheRadiusPacket;
 import net.minecraft.network.protocol.game.ClientboundSetSimulationDistancePacket;
@@ -22,10 +22,10 @@ import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.commons.lang3.mutable.MutableObject;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.TreeSet;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.ConcurrentSkipListSet;
 import java.util.concurrent.atomic.AtomicInteger;
 
 public final class PlayerChunkLoader {
@@ -76,10 +76,10 @@ public final class PlayerChunkLoader {
     }
 
     protected final ChunkMap chunkMap;
-    protected final Reference2ObjectLinkedOpenHashMap<ServerPlayer, PlayerLoaderData> playerMap = new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f);
-    protected final ReferenceLinkedOpenHashSet<PlayerLoaderData> chunkSendQueue = new ReferenceLinkedOpenHashSet<>(512, 0.7f);
+    protected final Reference2ObjectMap<ServerPlayer, PlayerLoaderData> playerMap = Reference2ObjectMaps.synchronize(new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f));
+    protected final Deque<PlayerLoaderData> chunkSendQueue = new ConcurrentLinkedDeque<>();
 
-    protected final TreeSet<PlayerLoaderData> chunkLoadQueue = new TreeSet<>((final PlayerLoaderData p1, final PlayerLoaderData p2) -> {
+    protected final NavigableSet<PlayerLoaderData> chunkLoadQueue = new ConcurrentSkipListSet<>((final PlayerLoaderData p1, final PlayerLoaderData p2) -> {
         if (p1 == p2) {
             return 0;
         }
@@ -109,7 +109,7 @@ public final class PlayerChunkLoader {
         return Integer.compare(System.identityHashCode(p1), System.identityHashCode(p2));
     });
 
-    protected final TreeSet<PlayerLoaderData> chunkSendWaitQueue = new TreeSet<>((final PlayerLoaderData p1, final PlayerLoaderData p2) -> {
+    protected final NavigableSet<PlayerLoaderData> chunkSendWaitQueue = new ConcurrentSkipListSet<>((final PlayerLoaderData p1, final PlayerLoaderData p2) -> {
         if (p1 == p2) {
             return 0;
         }
@@ -308,8 +308,8 @@ public final class PlayerChunkLoader {
                 });
     }
 
-    protected final LongOpenHashSet isTargetedForPlayerLoad = new LongOpenHashSet();
-    protected final LongOpenHashSet chunkTicketTracker = new LongOpenHashSet();
+    protected final LongSet isTargetedForPlayerLoad = LongSets.synchronize(new LongOpenHashSet());
+    protected final LongSet chunkTicketTracker = LongSets.synchronize(new LongOpenHashSet());
 
     public boolean isChunkNearPlayers(final int chunkX, final int chunkZ) {
         final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
@@ -373,7 +373,7 @@ public final class PlayerChunkLoader {
         }
 
         return !(data.hasSentChunk(chunkX - 1, chunkZ) && data.hasSentChunk(chunkX + 1, chunkZ) &&
-            data.hasSentChunk(chunkX, chunkZ - 1) && data.hasSentChunk(chunkX, chunkZ + 1));
+                data.hasSentChunk(chunkX, chunkZ - 1) && data.hasSentChunk(chunkX, chunkZ + 1));
     }
 
     protected int getMaxConcurrentChunkSends() {
@@ -523,17 +523,14 @@ public final class PlayerChunkLoader {
         if (time < nextChunkSend) {
             return;
         }
+        PlayerLoaderData data1;
         // drain entries from wait queue
-        while (!this.chunkSendWaitQueue.isEmpty()) {
-            final PlayerLoaderData data = this.chunkSendWaitQueue.first();
-
-            if (data.nextChunkSendTarget > time) {
+        while ((data1 = this.chunkSendWaitQueue.pollFirst())!=null) {
+            if (data1.nextChunkSendTarget > time) {
+                this.chunkSendWaitQueue.add(data1);
                 break;
             }
-
-            this.chunkSendWaitQueue.pollFirst();
-
-            this.chunkSendQueue.add(data);
+            this.chunkSendQueue.add(data1);
         }
 
         if (this.chunkSendQueue.isEmpty()) {
@@ -542,10 +539,9 @@ public final class PlayerChunkLoader {
 
         final int maxSends = this.getMaxConcurrentChunkSends();
         final long nextPlayerDeadline = this.getTargetSendPerPlayerAddend() + time;
-        for (;;) {
-            if (this.chunkSendQueue.isEmpty()) {
-                break;
-            }
+        final Deque<PlayerLoaderData> tempCopy = new ArrayDeque<>(this.chunkSendQueue);
+        PlayerLoaderData data;
+        while ((data = tempCopy.pollFirst())!=null) {
             final int currSends = concurrentChunkSends.get();
             if (currSends >= maxSends) {
                 break;
@@ -554,19 +550,12 @@ public final class PlayerChunkLoader {
             if (!concurrentChunkSends.compareAndSet(currSends, currSends + 1)) {
                 continue;
             }
-
             // send chunk
-
-            final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
-
+            this.chunkSendQueue.remove(data);
             final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
             if (queuedSend == null) {
                 concurrentChunkSends.getAndDecrement(); // we never sent, so decrease
                 // stop iterating over players who have nothing to send
-                if (this.chunkSendQueue.isEmpty()) {
-                    // nothing left
-                    break;
-                }
                 continue;
             }
 
@@ -581,17 +570,18 @@ public final class PlayerChunkLoader {
                 this.sendingChunkCounts.addTo(data, 1);
             }
 
+            final PlayerLoaderData finalData = data;
             data.sendChunk(queuedSend.chunkX, queuedSend.chunkZ, () -> {
                 synchronized (this.sendingChunkCounts) {
-                    final int count = this.sendingChunkCounts.getInt(data);
+                    final int count = this.sendingChunkCounts.getInt(finalData);
                     if (count == 0) {
                         // disconnected, so we don't need to decrement: it will be decremented for us
                         return;
                     }
                     if (count == 1) {
-                        this.sendingChunkCounts.removeInt(data);
+                        this.sendingChunkCounts.removeInt(finalData);
                     } else {
-                        this.sendingChunkCounts.put(data, count - 1);
+                        this.sendingChunkCounts.put(finalData, count - 1);
                     }
                 }
 
@@ -618,16 +608,12 @@ public final class PlayerChunkLoader {
         final int maxLoads = this.getMaxChunkLoads();
         final long time = System.nanoTime();
         boolean updatedCounters = false;
-        for (;;) {
-            final PlayerLoaderData data = this.chunkLoadQueue.pollFirst();
-
+        PlayerLoaderData data;
+        while ((data = this.chunkLoadQueue.pollFirst())!=null) {
             data.lastChunkLoad = time;
 
             final ChunkPriorityHolder queuedLoad = data.loadQueue.peekFirst();
             if (queuedLoad == null) {
-                if (this.chunkLoadQueue.isEmpty()) {
-                    break;
-                }
                 continue;
             }
 
@@ -673,7 +659,7 @@ public final class PlayerChunkLoader {
 
                 final int currentChunkLoads = this.concurrentChunkLoads;
                 if (currentChunkLoads >= maxLoads || (GlobalConfiguration.get().chunkLoading.globalMaxChunkLoadRate > 0 && (TICKET_ADDITION_COUNTER_SHORT.getRate() >= GlobalConfiguration.get().chunkLoading.globalMaxChunkLoadRate || TICKET_ADDITION_COUNTER_LONG.getRate() >= GlobalConfiguration.get().chunkLoading.globalMaxChunkLoadRate))
-                    || (GlobalConfiguration.get().chunkLoading.playerMaxChunkLoadRate > 0.0 && (data.ticketAdditionCounterShort.getRate() >= GlobalConfiguration.get().chunkLoading.playerMaxChunkLoadRate || data.ticketAdditionCounterLong.getRate() >= GlobalConfiguration.get().chunkLoading.playerMaxChunkLoadRate))) {
+                        || (GlobalConfiguration.get().chunkLoading.playerMaxChunkLoadRate > 0.0 && (data.ticketAdditionCounterShort.getRate() >= GlobalConfiguration.get().chunkLoading.playerMaxChunkLoadRate || data.ticketAdditionCounterLong.getRate() >= GlobalConfiguration.get().chunkLoading.playerMaxChunkLoadRate))) {
                     // don't poll, we didn't load it
                     this.chunkLoadQueue.add(data);
                     break;
@@ -786,11 +772,11 @@ public final class PlayerChunkLoader {
 
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
-        protected final ArrayDeque<ChunkPriorityHolder> loadQueue = new ArrayDeque<>();
-        protected final LongOpenHashSet sentChunks = new LongOpenHashSet();
-        protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
+        protected final Deque<ChunkPriorityHolder> loadQueue = new ConcurrentLinkedDeque<>();
+        protected final LongSet sentChunks = LongSets.synchronize(new LongOpenHashSet());
+        protected final LongSet chunksToBeSent = LongSets.synchronize(new LongOpenHashSet());
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
+        protected final NavigableSet<ChunkPriorityHolder> sendQueue = new ConcurrentSkipListSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
             final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
             if (distanceCompare != 0) {
                 return distanceCompare;
@@ -964,14 +950,14 @@ public final class PlayerChunkLoader {
                             && tickViewDistance == this.lastTickDistance
 
                             && (this.usingLookingPriority ? (
-                                    // has our block stayed the same (this also accounts for chunk change)?
-                                    Mth.floor(this.lastLocX) == Mth.floor(posX)
+                            // has our block stayed the same (this also accounts for chunk change)?
+                            Mth.floor(this.lastLocX) == Mth.floor(posX)
                                     && Mth.floor(this.lastLocZ) == Mth.floor(posZ)
-                            ) : (
-                                    // has our chunk stayed the same
-                                    (Mth.floor(this.lastLocX) >> 4) == (Mth.floor(posX) >> 4)
+                    ) : (
+                            // has our chunk stayed the same
+                            (Mth.floor(this.lastLocX) >> 4) == (Mth.floor(posX) >> 4)
                                     && (Mth.floor(this.lastLocZ) >> 4) == (Mth.floor(posZ) >> 4)
-                            ))
+                    ))
 
                             // has our decision about look priority changed?
                             && this.usingLookingPriority == useLookPriority
diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 61c170555c8854b102c640b0b6a615f9f732edbf..387d07868301877dd7fca5d8dfd21e1331f4793e 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -6,8 +6,15 @@ import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
 import io.papermc.paper.util.WorldUtil;
 import io.papermc.paper.world.ChunkEntitySlices;
+import it.unimi.dsi.fastutil.ints.Int2ReferenceArrayMap;
+import it.unimi.dsi.fastutil.ints.Int2ReferenceMap;
 import it.unimi.dsi.fastutil.ints.Int2ReferenceOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectArrayMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2ReferenceArrayMap;
+import it.unimi.dsi.fastutil.objects.Object2ReferenceMap;
 import it.unimi.dsi.fastutil.objects.Object2ReferenceOpenHashMap;
 import net.minecraft.core.BlockPos;
 import io.papermc.paper.chunk.system.ChunkSystem;
@@ -31,6 +38,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.UUID;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.locks.StampedLock;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -45,16 +54,16 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
     public final ServerLevel world;
 
-    private final StampedLock stateLock = new StampedLock();
-    protected final Long2ObjectOpenHashMap<ChunkSlicesRegion> regions = new Long2ObjectOpenHashMap<>(128, 0.5f);
+    private final StampedLock entityByLock = new StampedLock();
+    private final Lock regionLoadLock = new ReentrantLock(true);
+
+    protected final Long2ObjectMap<ChunkSlicesRegion> regions = Long2ObjectMaps.synchronize(new Long2ObjectArrayMap<>());
 
     private final int minSection; // inclusive
     private final int maxSection; // inclusive
     private final LevelCallback<Entity> worldCallback;
-
-    private final StampedLock entityByLock = new StampedLock();
-    private final Int2ReferenceOpenHashMap<Entity> entityById = new Int2ReferenceOpenHashMap<>();
-    private final Object2ReferenceOpenHashMap<UUID, Entity> entityByUUID = new Object2ReferenceOpenHashMap<>();
+    private final Int2ReferenceMap<Entity> entityById = new Int2ReferenceArrayMap<>();
+    private final Object2ReferenceMap<UUID, Entity> entityByUUID = new Object2ReferenceArrayMap<>();
     private final EntityList accessibleEntities = new EntityList();
 
     public EntityLookup(final ServerLevel world, final LevelCallback<Entity> worldCallback) {
@@ -105,7 +114,6 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         if (attempt != 0L) {
             try {
                 final Entity ret = this.entityByUUID.get(id);
-
                 if (this.entityByLock.validate(attempt)) {
                     return maskNonAccessible(ret);
                 }
@@ -166,12 +174,12 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
             }
 
             @Override
-            public boolean hasNext() {
+            public synchronized boolean hasNext() {
                 return this.off < this.length;
             }
 
             @Override
-            public T next() {
+            public synchronized T next() {
                 if (this.off >= this.length) {
                     throw new NoSuchElementException();
                 }
@@ -208,8 +216,8 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     public void get(final AABB box, final Consumer<Entity> action) {
         List<Entity> entities = new ArrayList<>();
         this.getEntitiesWithoutDragonParts(null, box, entities, null);
-        for (int i = 0, len = entities.size(); i < len; ++i) {
-            action.accept(entities.get(i));
+        for (Entity entity : entities) {
+            action.accept(entity);
         }
     }
 
@@ -217,8 +225,8 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     public <U extends Entity> void get(final EntityTypeTest<Entity, U> filter, final AABB box, final AbortableIterationConsumer<U> action) {
         List<Entity> entities = new ArrayList<>();
         this.getEntitiesWithoutDragonParts(null, box, entities, null);
-        for (int i = 0, len = entities.size(); i < len; ++i) {
-            final U casted = filter.tryCast(entities.get(i));
+        for (Entity entity : entities) {
+            final U casted = filter.tryCast(entity);
             if (casted != null && action.accept(casted).shouldAbort()) {
                 break;
             }
@@ -228,75 +236,50 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     public void entityStatusChange(final Entity entity, final ChunkEntitySlices slices, final Visibility oldVisibility, final Visibility newVisibility, final boolean moved,
                                    final boolean created, final boolean destroyed) {
         TickThread.ensureTickThread(entity, "Entity status change must only happen on the main thread");
-
-        if (entity.updatingSectionStatus) {
-            // recursive status update
-            LOGGER.error("Cannot recursively update entity chunk status for entity " + entity, new Throwable());
-            return;
-        }
-
-        final boolean entityStatusUpdateBefore = slices == null ? false : slices.startPreventingStatusUpdates();
-
-        if (entityStatusUpdateBefore) {
-            LOGGER.error("Cannot update chunk status for entity " + entity + " since entity chunk (" + slices.chunkX + "," + slices.chunkZ + ") is receiving update", new Throwable());
-            return;
-        }
-
+        final Boolean ticketBlockBefore = this.world.chunkTaskScheduler.chunkHolderManager.blockTicketUpdates();
         try {
-            final Boolean ticketBlockBefore = this.world.chunkTaskScheduler.chunkHolderManager.blockTicketUpdates();
-            try {
-                entity.updatingSectionStatus = true;
-                try {
-                    if (created) {
-                        EntityLookup.this.worldCallback.onCreated(entity);
-                    }
+            if (created) {
+                EntityLookup.this.worldCallback.onCreated(entity);
+            }
 
-                    if (oldVisibility == newVisibility) {
-                        if (moved && newVisibility.isAccessible()) {
-                            EntityLookup.this.worldCallback.onSectionChange(entity);
-                        }
-                        return;
-                    }
+            if (oldVisibility == newVisibility) {
+                if (moved && newVisibility.isAccessible()) {
+                    EntityLookup.this.worldCallback.onSectionChange(entity);
+                }
+                return;
+            }
 
-                    if (newVisibility.ordinal() > oldVisibility.ordinal()) {
-                        // status upgrade
-                        if (!oldVisibility.isAccessible() && newVisibility.isAccessible()) {
-                            this.accessibleEntities.add(entity);
-                            EntityLookup.this.worldCallback.onTrackingStart(entity);
-                        }
+            if (newVisibility.ordinal() > oldVisibility.ordinal()) {
+                // status upgrade
+                if (!oldVisibility.isAccessible() && newVisibility.isAccessible()) {
+                    this.accessibleEntities.add(entity);
+                    EntityLookup.this.worldCallback.onTrackingStart(entity);
+                }
 
-                        if (!oldVisibility.isTicking() && newVisibility.isTicking()) {
-                            EntityLookup.this.worldCallback.onTickingStart(entity);
-                        }
-                    } else {
-                        // status downgrade
-                        if (oldVisibility.isTicking() && !newVisibility.isTicking()) {
-                            EntityLookup.this.worldCallback.onTickingEnd(entity);
-                        }
+                if (!oldVisibility.isTicking() && newVisibility.isTicking()) {
+                    EntityLookup.this.worldCallback.onTickingStart(entity);
+                }
+            } else {
+                // status downgrade
+                if (oldVisibility.isTicking() && !newVisibility.isTicking()) {
+                    EntityLookup.this.worldCallback.onTickingEnd(entity);
+                }
 
-                        if (oldVisibility.isAccessible() && !newVisibility.isAccessible()) {
-                            this.accessibleEntities.remove(entity);
-                            EntityLookup.this.worldCallback.onTrackingEnd(entity);
-                        }
-                    }
+                if (oldVisibility.isAccessible() && !newVisibility.isAccessible()) {
+                    this.accessibleEntities.remove(entity);
+                    EntityLookup.this.worldCallback.onTrackingEnd(entity);
+                }
+            }
 
-                    if (moved && newVisibility.isAccessible()) {
-                        EntityLookup.this.worldCallback.onSectionChange(entity);
-                    }
+            if (moved && newVisibility.isAccessible()) {
+                EntityLookup.this.worldCallback.onSectionChange(entity);
+            }
 
-                    if (destroyed) {
-                        EntityLookup.this.worldCallback.onDestroyed(entity);
-                    }
-                } finally {
-                    entity.updatingSectionStatus = false;
-                }
-            } finally {
-                this.world.chunkTaskScheduler.chunkHolderManager.unblockTicketUpdates(ticketBlockBefore);
+            if (destroyed) {
+                EntityLookup.this.worldCallback.onDestroyed(entity);
             }
         } finally {
-            if (slices != null) {
-                slices.stopPreventingStatusUpdates(false);
-            }
+            this.world.chunkTaskScheduler.chunkHolderManager.unblockTicketUpdates(ticketBlockBefore);
         }
     }
 
@@ -346,11 +329,6 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
             return false;
         }
 
-        if (entity.updatingSectionStatus) {
-            LOGGER.warn("Entity " + entity + " is currently prevented from being added/removed to world since it is processing section status updates", new Throwable());
-            return false;
-        }
-
         if (fromDisk) {
             ChunkSystem.onEntityPreAdd(this.world, entity);
             if (entity.isRemoved()) {
@@ -398,7 +376,14 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         if (!entity.isRemoved()) {
             throw new IllegalStateException("Only call Entity#setRemoved to remove an entity");
         }
-        final ChunkEntitySlices slices = this.getChunk(sectionX, sectionZ);
+        ChunkEntitySlices slices;
+        this.regionLoadLock.lock();
+        try {
+            slices = this.getChunk(sectionX, sectionZ);
+        }finally {
+            this.regionLoadLock.unlock();
+        }
+
         // all entities should be in a chunk
         if (slices == null) {
             LOGGER.warn("Cannot remove entity " + entity + " from null entity slices (" + sectionX + "," + sectionZ + ")");
@@ -441,7 +426,15 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         // ensure the old section is owned by this tick thread
         TickThread.ensureTickThread(this.world, entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
 
-        final ChunkEntitySlices old = this.getChunk(entity.sectionX, entity.sectionZ);
+        ChunkEntitySlices old;
+
+        this.regionLoadLock.lock();
+        try {
+            old = this.getChunk(entity.sectionX, entity.sectionZ);
+        }finally {
+            this.regionLoadLock.unlock();
+        }
+
         final ChunkEntitySlices slices = this.getOrCreateChunk(newSectionX, newSectionZ);
 
         if (!old.removeEntity(entity, entity.sectionY)) {
@@ -609,7 +602,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
                             continue;
                         }
 
-                        chunk.getEntities(type, box, (List)into, (Predicate)predicate);
+                        chunk.getEntities(type, box, (List) into, (Predicate) predicate);
                     }
                 }
             }
@@ -660,18 +653,22 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot load in entity section off-main");
         synchronized (this) {
             final ChunkEntitySlices curr = this.getChunk(chunkX, chunkZ);
-            if (curr != null) {
-                this.removeChunk(chunkX, chunkZ);
-
-                curr.mergeInto(slices);
-
-                this.addChunk(chunkX, chunkZ, slices);
-            } else {
-                this.addChunk(chunkX, chunkZ, slices);
+            this.regionLoadLock.lock();
+            try {
+                if (curr != null) {
+                    this.removeChunk(chunkX, chunkZ);
+                    curr.mergeInto(slices);
+                    this.addChunk(chunkX, chunkZ, slices);
+                } else {
+                    this.addChunk(chunkX, chunkZ, slices);
+                }
+            } finally {
+                this.regionLoadLock.unlock();
             }
         }
     }
 
+
     public void entitySectionUnload(final int chunkX, final int chunkZ) {
         TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot unload entity section off-main");
         this.removeChunk(chunkX, chunkZ);
@@ -699,27 +696,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
 
     public ChunkSlicesRegion getRegion(final int regionX, final int regionZ) {
         final long key = CoordinateUtils.getChunkKey(regionX, regionZ);
-        final long attempt = this.stateLock.tryOptimisticRead();
-        if (attempt != 0L) {
-            try {
-                final ChunkSlicesRegion ret = this.regions.get(key);
-
-                if (this.stateLock.validate(attempt)) {
-                    return ret;
-                }
-            } catch (final Error error) {
-                throw error;
-            } catch (final Throwable thr) {
-                // ignore
-            }
-        }
-
-        this.stateLock.readLock();
-        try {
-            return this.regions.get(key);
-        } finally {
-            this.stateLock.tryUnlockRead();
-        }
+        return this.regions.get(key);
     }
 
     private synchronized void removeChunk(final int chunkX, final int chunkZ) {
@@ -730,12 +707,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         final int remaining = region.remove(relIndex);
 
         if (remaining == 0) {
-            this.stateLock.writeLock();
-            try {
-                this.regions.remove(key);
-            } finally {
-                this.stateLock.tryUnlockWrite();
-            }
+            this.regions.remove(key);
         }
     }
 
@@ -749,12 +721,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         } else {
             region = new ChunkSlicesRegion();
             region.add(relIndex, slices);
-            this.stateLock.writeLock();
-            try {
-                this.regions.put(key, region);
-            } finally {
-                this.stateLock.tryUnlockWrite();
-            }
+            this.regions.put(key, region);
         }
     }
 
@@ -831,9 +798,11 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         public static final NoOpCallback INSTANCE = new NoOpCallback();
 
         @Override
-        public void onMove() {}
+        public void onMove() {
+        }
 
         @Override
-        public void onRemove(final Entity.RemovalReason reason) {}
+        public void onRemove(final Entity.RemovalReason reason) {
+        }
     }
 }
diff --git a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
index 830d863cd9665d58875bfa5ca2bcd22f89ab2d49..15eeea40bb7a44470f6f3f0e2473cb451812eec1 100644
--- a/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/io/papermc/paper/chunk/system/scheduling/ChunkHolderManager.java
@@ -13,14 +13,10 @@ import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
 import io.papermc.paper.util.misc.Delayed8WayDistancePropagator2D;
 import io.papermc.paper.world.ChunkEntitySlices;
-import it.unimi.dsi.fastutil.longs.Long2IntLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2IntMap;
-import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongArrayList;
-import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet;
+import it.unimi.dsi.fastutil.objects.ObjectSortedSet;
+import it.unimi.dsi.fastutil.objects.ObjectSortedSets;
 import it.unimi.dsi.fastutil.objects.ReferenceLinkedOpenHashSet;
 import net.minecraft.nbt.CompoundTag;
 import io.papermc.paper.chunk.system.ChunkSystem;
@@ -39,13 +35,8 @@ import org.bukkit.plugin.Plugin;
 import org.slf4j.Logger;
 import java.io.IOException;
 import java.text.DecimalFormat;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
+import java.util.*;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
@@ -67,16 +58,16 @@ public final class ChunkHolderManager {
     final ReentrantLock ticketLock = new ReentrantLock();
 
     private final SWMRLong2ObjectHashTable<NewChunkHolder> chunkHolders = new SWMRLong2ObjectHashTable<>(16384, 0.25f);
-    private final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap<>(8192, 0.25f);
+    private final Long2ObjectMap<SortedArraySet<Ticket<?>>> tickets = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>(8192, 0.25f));
     // what a disaster of a name
     // this is a map of removal tick to a map of chunks and the number of tickets a chunk has that are to expire that tick
-    private final Long2ObjectOpenHashMap<Long2IntOpenHashMap> removeTickToChunkExpireTicketCount = new Long2ObjectOpenHashMap<>();
+    private final Long2ObjectMap<Long2IntOpenHashMap> removeTickToChunkExpireTicketCount = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>());
     private final ServerLevel world;
     private final ChunkTaskScheduler taskScheduler;
     private long currentTick;
 
-    private final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = new ArrayDeque<>();
-    private final ObjectRBTreeSet<NewChunkHolder> autoSaveQueue = new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
+    private final Deque<NewChunkHolder> pendingFullLoadUpdate = new ConcurrentLinkedDeque<>();
+    private final ObjectSortedSet<NewChunkHolder> autoSaveQueue = ObjectSortedSets.synchronize(new ObjectRBTreeSet<>((final NewChunkHolder c1, final NewChunkHolder c2) -> {
         if (c1 == c2) {
             return 0;
         }
@@ -95,7 +86,7 @@ public final class ChunkHolderManager {
         }
 
         return Long.compare(coord1, coord2);
-    });
+    }));
 
     public ChunkHolderManager(final ServerLevel world, final ChunkTaskScheduler taskScheduler) {
         this.world = world;
@@ -311,7 +302,7 @@ public final class ChunkHolderManager {
     public Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> getTicketsCopy() {
         this.ticketLock.lock();
         try {
-            return this.tickets.clone();
+            return new Long2ObjectOpenHashMap<>(this.tickets);
         } finally {
             this.ticketLock.unlock();
         }
@@ -784,7 +775,7 @@ public final class ChunkHolderManager {
         }
         if (!TickThread.isTickThread()) {
             this.taskScheduler.scheduleChunkTask(() -> {
-                final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
+                final Deque<NewChunkHolder> pendingFullLoadUpdate = ChunkHolderManager.this.pendingFullLoadUpdate;
                 for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                     pendingFullLoadUpdate.add(changedFullStatus.get(i));
                 }
@@ -792,7 +783,7 @@ public final class ChunkHolderManager {
                 ChunkHolderManager.this.processPendingFullUpdate();
             }, PrioritisedExecutor.Priority.HIGHEST);
         } else {
-            final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+            final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
             for (int i = 0, len = changedFullStatus.size(); i < len; ++i) {
                 pendingFullLoadUpdate.add(changedFullStatus.get(i));
             }
@@ -1039,7 +1030,7 @@ public final class ChunkHolderManager {
 
     // only call on tick thread
     protected final boolean processPendingFullUpdate() {
-        final ArrayDeque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
+        final Deque<NewChunkHolder> pendingFullLoadUpdate = this.pendingFullLoadUpdate;
 
         boolean ret = false;
 
diff --git a/src/main/java/io/papermc/paper/util/CachedLists.java b/src/main/java/io/papermc/paper/util/CachedLists.java
index e08f4e39db4ee3fed62e37364d17dcc5c5683504..f543462240e744e3424d302eb62be46c70ef9377 100644
--- a/src/main/java/io/papermc/paper/util/CachedLists.java
+++ b/src/main/java/io/papermc/paper/util/CachedLists.java
@@ -1,57 +1,22 @@
 package io.papermc.paper.util;
 
+import com.google.common.collect.Lists;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.phys.AABB;
-import org.bukkit.Bukkit;
-import org.bukkit.craftbukkit.util.UnsafeList;
 import java.util.List;
 
 public final class CachedLists {
-
-    // Paper start - optimise collisions
-    static final UnsafeList<AABB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
-    static boolean tempCollisionListInUse;
-
-    public static UnsafeList<AABB> getTempCollisionList() {
-        if (!Bukkit.isPrimaryThread() || tempCollisionListInUse) {
-            return new UnsafeList<>(16);
-        }
-        tempCollisionListInUse = true;
-        return TEMP_COLLISION_LIST;
-    }
-
-    public static void returnTempCollisionList(List<AABB> list) {
-        if (list != TEMP_COLLISION_LIST) {
-            return;
-        }
-        ((UnsafeList)list).setSize(0);
-        tempCollisionListInUse = false;
+    public static List<AABB> getTempCollisionList() {
+        return Lists.newCopyOnWriteArrayList();
     }
 
-    static final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
-    static boolean tempGetEntitiesListInUse;
+    public static void returnTempCollisionList(List<AABB> list) {}
 
-    public static UnsafeList<Entity> getTempGetEntitiesList() {
-        if (!Bukkit.isPrimaryThread() || tempGetEntitiesListInUse) {
-            return new UnsafeList<>(16);
-        }
-        tempGetEntitiesListInUse = true;
-        return TEMP_GET_ENTITIES_LIST;
+    public static List<Entity> getTempGetEntitiesList() {
+        return Lists.newCopyOnWriteArrayList();
     }
 
-    public static void returnTempGetEntitiesList(List<Entity> list) {
-        if (list != TEMP_GET_ENTITIES_LIST) {
-            return;
-        }
-        ((UnsafeList)list).setSize(0);
-        tempGetEntitiesListInUse = false;
-    }
-    // Paper end - optimise collisions
+    public static void returnTempGetEntitiesList(List<Entity> list) {}
 
-    public static void reset() {
-        // Paper start - optimise collisions
-        TEMP_COLLISION_LIST.completeReset();
-        TEMP_GET_ENTITIES_LIST.completeReset();
-        // Paper end - optimise collisions
-    }
+    public static void reset() {}
 }
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index fc57850b80303fcade89ca95794f63910404a407..026641ec3da6d9492f075656a2a7d90ddf458327 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -1,9 +1,10 @@
 package io.papermc.paper.util;
 
+import cc.keyimc.keyi.concurrent.thread.Worker;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
-import org.bukkit.Bukkit;
+
 import java.util.concurrent.atomic.AtomicInteger;
 
 public class TickThread extends Thread {
@@ -74,14 +75,14 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThread() {
-        return Thread.currentThread() instanceof TickThread;
+        return Thread.currentThread() instanceof TickThread || Thread.currentThread() instanceof Worker;
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final int chunkX, final int chunkZ) {
-        return Thread.currentThread() instanceof TickThread;
+        return Thread.currentThread() instanceof TickThread || Thread.currentThread() instanceof Worker;
     }
 
     public static boolean isTickThreadFor(final Entity entity) {
-        return Thread.currentThread() instanceof TickThread;
+        return Thread.currentThread() instanceof TickThread || Thread.currentThread() instanceof Worker;
     }
 }
diff --git a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
index 0fd814f1d65c111266a2b20f86561839a4cef755..fe4d76875462ac9d408c972b968647af78f2ed14 100644
--- a/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
+++ b/src/main/java/io/papermc/paper/util/maplist/IteratorSafeOrderedReferenceSet.java
@@ -94,7 +94,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         return 1.0 - ((double)this.indexMap.size() / (double)this.listSize);
     }
 
-    public int createRawIterator() {
+    public synchronized int createRawIterator() {
         if (this.allowSafeIteration()) {
             ++this.iteratorCount;
         }
@@ -105,7 +105,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         }
     }
 
-    public int advanceRawIterator(final int index) {
+    public synchronized int advanceRawIterator(final int index) {
         final E[] elements = this.listElements;
         int ret = index + 1;
         for (int len = this.listSize; ret < len; ++ret) {
@@ -117,7 +117,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         return -1;
     }
 
-    public void finishRawIterator() {
+    public synchronized void finishRawIterator() {
         if (this.allowSafeIteration() && --this.iteratorCount == 0) {
             if (this.getFragFactor() >= this.maxFragFactor) {
                 this.defrag();
@@ -125,7 +125,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         }
     }
 
-    public boolean remove(final E element) {
+    public synchronized boolean remove(final E element) {
         final int index = this.indexMap.removeInt(element);
         if (index >= 0) {
             if (this.firstInvalidIndex < 0 || index < this.firstInvalidIndex) {
@@ -144,11 +144,11 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         return false;
     }
 
-    public boolean contains(final E element) {
+    public synchronized boolean contains(final E element) {
         return this.indexMap.containsKey(element);
     }
 
-    public boolean add(final E element) {
+    public synchronized boolean add(final E element) {
         final int listSize = this.listSize;
 
         final int previous = this.indexMap.putIfAbsent(element, listSize);
@@ -223,30 +223,30 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         //this.check();
     }
 
-    public E rawGet(final int index) {
+    public synchronized E rawGet(final int index) {
         return this.listElements[index];
     }
 
-    public int size() {
+    public synchronized int size() {
         // always returns the correct amount - listSize can be different
         return this.indexMap.size();
     }
 
-    public IteratorSafeOrderedReferenceSet.Iterator<E> iterator() {
+    public synchronized IteratorSafeOrderedReferenceSet.Iterator<E> iterator() {
         return this.iterator(0);
     }
 
-    public IteratorSafeOrderedReferenceSet.Iterator<E> iterator(final int flags) {
+    public synchronized IteratorSafeOrderedReferenceSet.Iterator<E> iterator(final int flags) {
         if (this.allowSafeIteration()) {
             ++this.iteratorCount;
         }
         return new BaseIterator<>(this, true, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listSize);
     }
 
-    public java.util.Iterator<E> unsafeIterator() {
+    public synchronized java.util.Iterator<E> unsafeIterator() {
         return this.unsafeIterator(0);
     }
-    public java.util.Iterator<E> unsafeIterator(final int flags) {
+    public synchronized java.util.Iterator<E> unsafeIterator(final int flags) {
         return new BaseIterator<>(this, false, (flags & ITERATOR_FLAG_SEE_ADDITIONS) != 0 ? Integer.MAX_VALUE : this.listSize);
     }
 
@@ -273,7 +273,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         }
 
         @Override
-        public boolean hasNext() {
+        public synchronized boolean hasNext() {
             if (this.finished) {
                 return false;
             }
@@ -297,7 +297,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         }
 
         @Override
-        public E next() {
+        public synchronized E next() {
             if (!this.hasNext()) {
                 throw new NoSuchElementException();
             }
@@ -310,7 +310,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         }
 
         @Override
-        public void remove() {
+        public synchronized void remove() {
             final E lastReturned = this.lastReturned;
             if (lastReturned == null) {
                 throw new IllegalStateException();
@@ -320,7 +320,7 @@ public final class IteratorSafeOrderedReferenceSet<E> {
         }
 
         @Override
-        public void finishedIterating() {
+        public synchronized void finishedIterating() {
             if (this.finished || !this.canFinish) {
                 throw new IllegalStateException();
             }
diff --git a/src/main/java/io/papermc/paper/util/misc/Delayed26WayDistancePropagator3D.java b/src/main/java/io/papermc/paper/util/misc/Delayed26WayDistancePropagator3D.java
index 470402573bc31106d5a63e415b958fb7f9c36aa9..e831738a2988746fe4e065f6ded811a8bdf5dabe 100644
--- a/src/main/java/io/papermc/paper/util/misc/Delayed26WayDistancePropagator3D.java
+++ b/src/main/java/io/papermc/paper/util/misc/Delayed26WayDistancePropagator3D.java
@@ -94,24 +94,42 @@ public final class Delayed26WayDistancePropagator3D {
 
     protected final void addToIncreaseWorkQueue(final long coordinate, final byte level) {
         final Delayed8WayDistancePropagator2D.WorkQueue queue = this.levelIncreaseWorkQueues[level];
-        queue.queuedCoordinates.enqueue(coordinate);
-        queue.queuedLevels.enqueue(level);
+
+        final long id = queue.lock.writeLock();
+        try {
+            queue.queuedCoordinates.add(coordinate);
+            queue.queuedLevels.add(level);
+        }finally {
+            queue.lock.unlockWrite(id);
+        }
 
         this.levelIncreaseWorkQueueBitset |= (1L << level);
     }
 
     protected final void addToIncreaseWorkQueue(final long coordinate, final byte index, final byte level) {
         final Delayed8WayDistancePropagator2D.WorkQueue queue = this.levelIncreaseWorkQueues[index];
-        queue.queuedCoordinates.enqueue(coordinate);
-        queue.queuedLevels.enqueue(level);
+
+        final long id = queue.lock.writeLock();
+        try {
+            queue.queuedCoordinates.add(coordinate);
+            queue.queuedLevels.add(level);
+        }finally {
+            queue.lock.unlockWrite(id);
+        }
 
         this.levelIncreaseWorkQueueBitset |= (1L << index);
     }
 
     protected final void addToRemoveWorkQueue(final long coordinate, final byte level) {
         final Delayed8WayDistancePropagator2D.WorkQueue queue = this.levelRemoveWorkQueues[level];
-        queue.queuedCoordinates.enqueue(coordinate);
-        queue.queuedLevels.enqueue(level);
+
+        final long id = queue.lock.writeLock();
+        try {
+            queue.queuedCoordinates.add(coordinate);
+            queue.queuedLevels.add(level);
+        }finally {
+            queue.lock.unlockWrite(id);
+        }
 
         this.levelRemoveWorkQueueBitset |= (1L << level);
     }
@@ -163,9 +181,20 @@ public final class Delayed26WayDistancePropagator3D {
              this.levelIncreaseWorkQueueBitset ^= (1L << queueIndex), queueIndex = 63 ^ Long.numberOfLeadingZeros(this.levelIncreaseWorkQueueBitset)) {
 
             final Delayed8WayDistancePropagator2D.WorkQueue queue = this.levelIncreaseWorkQueues[queueIndex];
-            while (!queue.queuedLevels.isEmpty()) {
-                final long coordinate = queue.queuedCoordinates.removeFirstLong();
-                byte level = queue.queuedLevels.removeFirstByte();
+            while (true) {
+
+                long coordinate;
+                byte level;
+                final long id = queue.lock.writeLock();
+                try {
+                    if (queue.queuedLevels.isEmpty()){
+                        break;
+                    }
+                    coordinate = queue.queuedCoordinates.removeFirst();
+                    level = queue.queuedLevels.removeFirst();
+                }finally {
+                    queue.lock.unlockWrite(id);
+                }
 
                 final boolean neighbourCheck = level < 0;
 
@@ -232,9 +261,19 @@ public final class Delayed26WayDistancePropagator3D {
              this.levelRemoveWorkQueueBitset ^= (1L << queueIndex), queueIndex = 63 ^ Long.numberOfLeadingZeros(this.levelRemoveWorkQueueBitset)) {
 
             final Delayed8WayDistancePropagator2D.WorkQueue queue = this.levelRemoveWorkQueues[queueIndex];
-            while (!queue.queuedLevels.isEmpty()) {
-                final long coordinate = queue.queuedCoordinates.removeFirstLong();
-                final byte level = queue.queuedLevels.removeFirstByte();
+            while (true) {
+                long coordinate;
+                byte level;
+                final long id = queue.lock.writeLock();
+                try {
+                    if (queue.queuedLevels.isEmpty()){
+                        break;
+                    }
+                    coordinate = queue.queuedCoordinates.removeFirst();
+                    level = queue.queuedLevels.removeFirst();
+                }finally {
+                    queue.lock.unlockWrite(id);
+                }
 
                 final byte currentLevel = this.levels.removeIfGreaterOrEqual(coordinate, level);
                 if (currentLevel == 0) {
diff --git a/src/main/java/io/papermc/paper/util/misc/Delayed8WayDistancePropagator2D.java b/src/main/java/io/papermc/paper/util/misc/Delayed8WayDistancePropagator2D.java
index 808d1449ac44ae86a650932365081fbaf178d141..0fa95d81bafc7fe5c1bede7a0608b54795a78fa0 100644
--- a/src/main/java/io/papermc/paper/util/misc/Delayed8WayDistancePropagator2D.java
+++ b/src/main/java/io/papermc/paper/util/misc/Delayed8WayDistancePropagator2D.java
@@ -1,12 +1,14 @@
 package io.papermc.paper.util.misc;
 
+import io.papermc.paper.util.MCUtil;
 import it.unimi.dsi.fastutil.HashCommon;
-import it.unimi.dsi.fastutil.bytes.ByteArrayFIFOQueue;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
-import io.papermc.paper.util.MCUtil;
+
+import java.util.Deque;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.locks.StampedLock;
 
 public final class Delayed8WayDistancePropagator2D {
 
@@ -356,24 +358,42 @@ public final class Delayed8WayDistancePropagator2D {
 
     protected final void addToIncreaseWorkQueue(final long coordinate, final byte level) {
         final WorkQueue queue = this.levelIncreaseWorkQueues[level];
-        queue.queuedCoordinates.enqueue(coordinate);
-        queue.queuedLevels.enqueue(level);
+
+        final long id = queue.lock.writeLock();
+        try {
+            queue.queuedCoordinates.add(coordinate);
+            queue.queuedLevels.add(level);
+        }finally {
+            queue.lock.unlockWrite(id);
+        }
 
         this.levelIncreaseWorkQueueBitset |= (1L << level);
     }
 
     protected final void addToIncreaseWorkQueue(final long coordinate, final byte index, final byte level) {
         final WorkQueue queue = this.levelIncreaseWorkQueues[index];
-        queue.queuedCoordinates.enqueue(coordinate);
-        queue.queuedLevels.enqueue(level);
+
+        final long id = queue.lock.writeLock();
+        try {
+            queue.queuedCoordinates.add(coordinate);
+            queue.queuedLevels.add(level);
+        }finally {
+            queue.lock.unlockWrite(id);
+        }
 
         this.levelIncreaseWorkQueueBitset |= (1L << index);
     }
 
     protected final void addToRemoveWorkQueue(final long coordinate, final byte level) {
         final WorkQueue queue = this.levelRemoveWorkQueues[level];
-        queue.queuedCoordinates.enqueue(coordinate);
-        queue.queuedLevels.enqueue(level);
+
+        final long id = queue.lock.writeLock();
+        try {
+            queue.queuedCoordinates.add(coordinate);
+            queue.queuedLevels.add(level);
+        }finally {
+            queue.lock.unlockWrite(id);
+        }
 
         this.levelRemoveWorkQueueBitset |= (1L << level);
     }
@@ -425,9 +445,19 @@ public final class Delayed8WayDistancePropagator2D {
              this.levelIncreaseWorkQueueBitset ^= (1L << queueIndex), queueIndex = 63 ^ Long.numberOfLeadingZeros(this.levelIncreaseWorkQueueBitset)) {
 
             final WorkQueue queue = this.levelIncreaseWorkQueues[queueIndex];
-            while (!queue.queuedLevels.isEmpty()) {
-                final long coordinate = queue.queuedCoordinates.removeFirstLong();
-                byte level = queue.queuedLevels.removeFirstByte();
+            while (true) {
+                byte level;
+                long coordinate;
+                final long id = queue.lock.writeLock();
+                try {
+                    if (queue.queuedLevels.isEmpty()){
+                        break;
+                    }
+                    coordinate = queue.queuedCoordinates.removeFirst();
+                    level = queue.queuedLevels.removeFirst();
+                }finally {
+                    queue.lock.unlockWrite(id);
+                }
 
                 final boolean neighbourCheck = level < 0;
 
@@ -491,9 +521,20 @@ public final class Delayed8WayDistancePropagator2D {
              this.levelRemoveWorkQueueBitset ^= (1L << queueIndex), queueIndex = 63 ^ Long.numberOfLeadingZeros(this.levelRemoveWorkQueueBitset)) {
 
             final WorkQueue queue = this.levelRemoveWorkQueues[queueIndex];
-            while (!queue.queuedLevels.isEmpty()) {
-                final long coordinate = queue.queuedCoordinates.removeFirstLong();
-                final byte level = queue.queuedLevels.removeFirstByte();
+            while (true) {
+                long coordinate;
+                byte level;
+
+                final long id = queue.lock.writeLock();
+                try {
+                    if (queue.queuedLevels.isEmpty()){
+                        break;
+                    }
+                    coordinate = queue.queuedCoordinates.removeFirst();
+                    level = queue.queuedLevels.removeFirst();
+                }finally {
+                    queue.lock.unlockWrite(id);
+                }
 
                 final byte currentLevel = this.levels.removeIfGreaterOrEqual(coordinate, level);
                 if (currentLevel == 0) {
@@ -678,41 +719,9 @@ public final class Delayed8WayDistancePropagator2D {
     }
 
     protected static final class WorkQueue {
-
-        public final NoResizeLongArrayFIFODeque queuedCoordinates = new NoResizeLongArrayFIFODeque();
-        public final NoResizeByteArrayFIFODeque queuedLevels = new NoResizeByteArrayFIFODeque();
-
+        public final Deque<Long> queuedCoordinates = new ConcurrentLinkedDeque<>();
+        public final Deque<Byte> queuedLevels = new ConcurrentLinkedDeque<>();
+        public final StampedLock lock = new StampedLock();
     }
 
-    protected static final class NoResizeLongArrayFIFODeque extends LongArrayFIFOQueue {
-
-        /**
-         * Assumes non-empty. If empty, undefined behaviour.
-         */
-        public long removeFirstLong() {
-            // copied from superclass
-            long t = this.array[this.start];
-            if (++this.start == this.length) {
-                this.start = 0;
-            }
-
-            return t;
-        }
-    }
-
-    protected static final class NoResizeByteArrayFIFODeque extends ByteArrayFIFOQueue {
-
-        /**
-         * Assumes non-empty. If empty, undefined behaviour.
-         */
-        public byte removeFirstByte() {
-            // copied from superclass
-            byte t = this.array[this.start];
-            if (++this.start == this.length) {
-                this.start = 0;
-            }
-
-            return t;
-        }
-    }
 }
diff --git a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
index f597d65d56964297eeeed6c7e77703764178fee0..b12c02962e9dad92ae79d762887c65db10765488 100644
--- a/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
+++ b/src/main/java/io/papermc/paper/world/ChunkEntitySlices.java
@@ -2,8 +2,8 @@ package io.papermc.paper.world;
 
 import com.destroystokyo.paper.util.maplist.EntityList;
 import io.papermc.paper.chunk.system.entity.EntityLookup;
-import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectMaps;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectOpenHashMap;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.server.level.ChunkHolder;
@@ -20,8 +20,8 @@ import net.minecraft.world.phys.AABB;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.locks.StampedLock;
 import java.util.function.Predicate;
 
 public final class ChunkEntitySlices {
@@ -31,15 +31,15 @@ public final class ChunkEntitySlices {
     public final int chunkX;
     public final int chunkZ;
     protected final ServerLevel world;
-
+    protected final StampedLock accessLock = new StampedLock(); //Hearse -- fix some entity can't be removed
     protected final EntityCollectionBySection allEntities;
     protected final EntityCollectionBySection hardCollidingEntities;
-    protected final Reference2ObjectOpenHashMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
+    protected final Reference2ObjectMap<Class<? extends Entity>, EntityCollectionBySection> entitiesByClass;
     protected final EntityList entities = new EntityList();
 
-    public ChunkHolder.FullChunkStatus status;
+    public volatile ChunkHolder.FullChunkStatus status;
 
-    protected boolean isTransient;
+    protected volatile boolean isTransient;
 
     public boolean isTransient() {
         return this.isTransient;
@@ -61,13 +61,12 @@ public final class ChunkEntitySlices {
 
         this.allEntities = new EntityCollectionBySection(this);
         this.hardCollidingEntities = new EntityCollectionBySection(this);
-        this.entitiesByClass = new Reference2ObjectOpenHashMap<>();
+        this.entitiesByClass = Reference2ObjectMaps.synchronize(new Reference2ObjectOpenHashMap<>());
 
         this.status = status;
     }
 
-    // Paper start - optimise CraftChunk#getEntities
-    public org.bukkit.entity.Entity[] getChunkEntities() {
+    private org.bukkit.entity.Entity[] getChunkEntitiesUnsafe(){
         List<org.bukkit.entity.Entity> ret = new java.util.ArrayList<>();
         final Entity[] entities = this.entities.getRawData();
         for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
@@ -80,11 +79,25 @@ public final class ChunkEntitySlices {
                 ret.add(bukkit);
             }
         }
-
         return ret.toArray(new org.bukkit.entity.Entity[0]);
     }
 
-    public CompoundTag save() {
+    // Paper start - optimise CraftChunk#getEntities
+    public org.bukkit.entity.Entity[] getChunkEntities() {
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)) {
+            return this.getChunkEntitiesUnsafe();
+        }
+
+        id = this.accessLock.readLock();
+        try {
+            return this.getChunkEntitiesUnsafe();
+        } finally {
+            this.accessLock.unlockRead(id);
+        }
+    }
+
+    private CompoundTag saveUnsafe(){
         final int len = this.entities.size();
         if (len == 0) {
             return null;
@@ -106,11 +119,36 @@ public final class ChunkEntitySlices {
         return EntityStorage.saveEntityChunk(collectedEntities, new ChunkPos(this.chunkX, this.chunkZ), this.world);
     }
 
+    public CompoundTag save() {
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            return this.saveUnsafe();
+        }
+        id = this.accessLock.readLock();
+        try {
+            return this.saveUnsafe();
+        } finally {
+            this.accessLock.unlockRead(id);
+        }
+    }
+
     // returns true if this chunk has transient entities remaining
     public boolean unload() {
-        final int len = this.entities.size();
-        final Entity[] collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
-
+        Entity[] collectedEntities;
+        int len;
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            len = this.entities.size();
+            collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
+        }else {
+            id = this.accessLock.readLock();
+            try {
+                len = this.entities.size();
+                collectedEntities = Arrays.copyOf(this.entities.getRawData(), len);
+            } finally {
+                this.accessLock.unlockRead(id);
+            }
+        }
         for (int i = 0; i < len; ++i) {
             final Entity entity = collectedEntities[i];
             if (entity.isRemoved()) {
@@ -128,7 +166,6 @@ public final class ChunkEntitySlices {
                 }
             }
         }
-
         return this.entities.size() != 0;
     }
 
@@ -140,53 +177,98 @@ public final class ChunkEntitySlices {
 
         final Entity[] rawData = this.entities.getRawData();
         final List<Entity> collectedEntities = new ArrayList<>(len);
-        for (int i = 0; i < len; ++i) {
-            collectedEntities.add(rawData[i]);
-        }
+        collectedEntities.addAll(Arrays.asList(rawData).subList(0, len));
 
         return collectedEntities;
     }
 
     public void callEntitiesLoadEvent() {
-        CraftEventFactory.callEntitiesLoadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), this.getAllEntities());
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            CraftEventFactory.callEntitiesLoadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), this.getAllEntities());
+            return;
+        }
+        id = this.accessLock.readLock();
+        try {
+            CraftEventFactory.callEntitiesLoadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), this.getAllEntities());
+        } finally {
+            this.accessLock.unlockRead(id);
+        }
     }
 
     public void callEntitiesUnloadEvent() {
-        CraftEventFactory.callEntitiesUnloadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), this.getAllEntities());
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            CraftEventFactory.callEntitiesUnloadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), this.getAllEntities());
+            return;
+        }
+        id = this.accessLock.readLock();
+        try {
+            CraftEventFactory.callEntitiesUnloadEvent(this.world, new ChunkPos(this.chunkX, this.chunkZ), this.getAllEntities());
+        } finally {
+            this.accessLock.unlockRead(id);
+        }
     }
     // Paper end - optimise CraftChunk#getEntities
 
     public boolean isEmpty() {
-        return this.entities.size() == 0;
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            return this.entities.size() == 0;
+        }
+        id = this.accessLock.readLock();
+        try {
+            return this.entities.size() == 0;
+        } finally {
+            this.accessLock.unlockRead(id);
+        }
     }
 
     public void mergeInto(final ChunkEntitySlices slices) {
-        final Entity[] entities = this.entities.getRawData();
-        for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
-            final Entity entity = entities[i];
+        final List<Entity> cop = new ArrayList<>();
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            final Entity[] entities = this.entities.getRawData();
+            for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
+                final Entity entity = entities[i];
+                cop.add(entity);
+            }
+        }else {
+            id = this.accessLock.readLock();
+            try {
+                final Entity[] entities = this.entities.getRawData();
+                for (int i = 0, size = Math.min(entities.length, this.entities.size()); i < size; ++i) {
+                    final Entity entity = entities[i];
+                    cop.add(entity);
+                }
+            } finally {
+                this.accessLock.unlockRead(id);
+            }
+        }
+        for (Entity entity : cop){
             slices.addEntity(entity, entity.sectionY);
         }
     }
 
-    private boolean preventStatusUpdates;
-    public boolean startPreventingStatusUpdates() {
-        final boolean ret = this.preventStatusUpdates;
-        this.preventStatusUpdates = true;
-        return ret;
-    }
-
-    public void stopPreventingStatusUpdates(final boolean prev) {
-        this.preventStatusUpdates = prev;
-    }
-
     public void updateStatus(final ChunkHolder.FullChunkStatus status, final EntityLookup lookup) {
         this.status = status;
 
-        final Entity[] entities = this.entities.getRawData();
+        Entity[] entities;
+
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            entities = Arrays.copyOf(this.entities.getRawData(), this.entities.getRawData().length);
+        }else {
+            id = this.accessLock.readLock();
+            try {
+                entities = Arrays.copyOf(this.entities.getRawData(), this.entities.getRawData().length);
+            } finally {
+                this.accessLock.unlockRead(id);
+            }
+        }
 
-        for (int i = 0, size = this.entities.size(); i < size; ++i) {
-            final Entity entity = entities[i];
 
+        for (final Entity entity : entities) {
             final Visibility oldVisibility = EntityLookup.getEntityStatus(entity);
             entity.chunkStatus = status;
             final Visibility newVisibility = EntityLookup.getEntityStatus(entity);
@@ -196,70 +278,112 @@ public final class ChunkEntitySlices {
     }
 
     public boolean addEntity(final Entity entity, final int chunkSection) {
-        if (!this.entities.add(entity)) {
-            return false;
-        }
-        entity.chunkStatus = this.status;
-        final int sectionIndex = chunkSection - this.minSection;
-
-        this.allEntities.addEntity(entity, sectionIndex);
+        long id = this.accessLock.writeLock();
+        try {
+            if (!this.entities.add(entity)) {
+                return false;
+            }
+            entity.chunkStatus = this.status;
+            final int sectionIndex = chunkSection - this.minSection;
 
-        if (entity.hardCollides()) {
-            this.hardCollidingEntities.addEntity(entity, sectionIndex);
-        }
+            this.allEntities.addEntity(entity, sectionIndex);
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
+            if (entity.hardCollides()) {
+                this.hardCollidingEntities.addEntity(entity, sectionIndex);
+            }
 
-            if (entry.getKey().isInstance(entity)) {
-                entry.getValue().addEntity(entity, sectionIndex);
+            for (final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry : this.entitiesByClass.reference2ObjectEntrySet()) {
+                if (entry.getKey().isInstance(entity)) {
+                    entry.getValue().addEntity(entity, sectionIndex);
+                }
             }
+        } finally {
+            this.accessLock.unlockWrite(id);
         }
-
         return true;
     }
 
     public boolean removeEntity(final Entity entity, final int chunkSection) {
-        if (!this.entities.remove(entity)) {
-            return false;
-        }
-        entity.chunkStatus = null;
-        final int sectionIndex = chunkSection - this.minSection;
-
-        this.allEntities.removeEntity(entity, sectionIndex);
+        long id = this.accessLock.writeLock();
+        try {
+            if (!this.entities.remove(entity)) {
+                return false;
+            }
+            entity.chunkStatus = null;
+            final int sectionIndex = chunkSection - this.minSection;
 
-        if (entity.hardCollides()) {
-            this.hardCollidingEntities.removeEntity(entity, sectionIndex);
-        }
+            this.allEntities.removeEntity(entity, sectionIndex);
 
-        for (final Iterator<Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection>> iterator =
-             this.entitiesByClass.reference2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry = iterator.next();
+            if (entity.hardCollides()) {
+                this.hardCollidingEntities.removeEntity(entity, sectionIndex);
+            }
 
-            if (entry.getKey().isInstance(entity)) {
-                entry.getValue().removeEntity(entity, sectionIndex);
+            for (final Reference2ObjectMap.Entry<Class<? extends Entity>, EntityCollectionBySection> entry : this.entitiesByClass.reference2ObjectEntrySet()) {
+                if (entry.getKey().isInstance(entity)) {
+                    entry.getValue().removeEntity(entity, sectionIndex);
+                }
             }
+        } finally {
+            this.accessLock.unlockWrite(id);
         }
-
         return true;
     }
 
     public void getHardCollidingEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
-        this.hardCollidingEntities.getEntities(except, box, into, predicate);
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            this.hardCollidingEntities.getEntities(except, box, into, predicate);
+            return;
+        }
+        id = this.accessLock.readLock();
+        try {
+            this.hardCollidingEntities.getEntities(except, box, into, predicate);
+        } finally {
+            this.accessLock.unlockRead(id);
+        }
     }
 
     public void getEntities(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
-        this.allEntities.getEntitiesWithEnderDragonParts(except, box, into, predicate);
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            this.allEntities.getEntitiesWithEnderDragonParts(except, box, into, predicate);
+            return;
+        }
+        id = this.accessLock.readLock();
+        try {
+            this.allEntities.getEntitiesWithEnderDragonParts(except, box, into, predicate);
+        } finally {
+            this.accessLock.unlockRead(id);
+        }
     }
 
     public void getEntitiesWithoutDragonParts(final Entity except, final AABB box, final List<Entity> into, final Predicate<? super Entity> predicate) {
-        this.allEntities.getEntities(except, box, into, predicate);
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            this.allEntities.getEntities(except, box, into, predicate);
+            return;
+        }
+        id = this.accessLock.readLock();
+        try {
+            this.allEntities.getEntities(except, box, into, predicate);
+        } finally {
+            this.accessLock.unlockRead(id);
+        }
     }
 
     public <T extends Entity> void getEntities(final EntityType<?> type, final AABB box, final List<? super T> into,
                                                final Predicate<? super T> predicate) {
-        this.allEntities.getEntities(type, box, (List)into, (Predicate)predicate);
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            this.allEntities.getEntities(type, box, (List) into, (Predicate) predicate);
+            return;
+        }
+        id = this.accessLock.readLock();
+        try {
+            this.allEntities.getEntities(type, box, (List) into, (Predicate) predicate);
+        } finally {
+            this.accessLock.unlockRead(id);
+        }
     }
 
     protected EntityCollectionBySection initClass(final Class<? extends Entity> clazz) {
@@ -287,12 +411,28 @@ public final class ChunkEntitySlices {
 
     public <T extends Entity> void getEntities(final Class<? extends T> clazz, final Entity except, final AABB box, final List<? super T> into,
                                                final Predicate<? super T> predicate) {
-        EntityCollectionBySection collection = this.entitiesByClass.get(clazz);
-        if (collection != null) {
-            collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
-        } else {
-            this.entitiesByClass.putIfAbsent(clazz, collection = this.initClass(clazz));
-            collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List)into, (Predicate)predicate);
+        long id = this.accessLock.tryOptimisticRead();
+        if (this.accessLock.validate(id)){
+            EntityCollectionBySection collection = this.entitiesByClass.get(clazz);
+            if (collection != null) {
+                collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List) into, (Predicate) predicate);
+            } else {
+                this.entitiesByClass.putIfAbsent(clazz, collection = this.initClass(clazz));
+                collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List) into, (Predicate) predicate);
+            }
+            return;
+        }
+        id = this.accessLock.readLock();
+        try {
+            EntityCollectionBySection collection = this.entitiesByClass.get(clazz);
+            if (collection != null) {
+                collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List) into, (Predicate) predicate);
+            } else {
+                this.entitiesByClass.putIfAbsent(clazz, collection = this.initClass(clazz));
+                collection.getEntitiesWithEnderDragonParts(except, clazz, box, (List) into, (Predicate) predicate);
+            }
+        } finally {
+            this.accessLock.unlockRead(id);
         }
     }
 
@@ -309,7 +449,7 @@ public final class ChunkEntitySlices {
         }
 
         public BasicEntityList(final int cap) {
-            this.storage = (E[])(cap <= 0 ? EMPTY : new Entity[cap]);
+            this.storage = (E[]) (cap <= 0 ? EMPTY : new Entity[cap]);
         }
 
         public boolean isEmpty() {
@@ -322,7 +462,7 @@ public final class ChunkEntitySlices {
 
         private void resize() {
             if (this.storage == EMPTY) {
-                this.storage = (E[])new Entity[DEFAULT_CAPACITY];
+                this.storage = (E[]) new Entity[DEFAULT_CAPACITY];
             } else {
                 this.storage = Arrays.copyOf(this.storage, this.storage.length * 2);
             }
@@ -492,7 +632,7 @@ public final class ChunkEntitySlices {
                     } // else: continue to test the ender dragon parts
 
                     if (entity instanceof EnderDragon) {
-                        for (final EnderDragonPart part : ((EnderDragon)entity).subEntities) {
+                        for (final EnderDragonPart part : ((EnderDragon) entity).subEntities) {
                             if (part == except || !part.getBoundingBox().intersects(box)) {
                                 continue;
                             }
@@ -543,7 +683,7 @@ public final class ChunkEntitySlices {
                     } // else: continue to test the ender dragon parts
 
                     if (entity instanceof EnderDragon) {
-                        for (final EnderDragonPart part : ((EnderDragon)entity).subEntities) {
+                        for (final EnderDragonPart part : ((EnderDragon) entity).subEntities) {
                             if (part == except || !part.getBoundingBox().intersects(box) || !clazz.isInstance(part)) {
                                 continue;
                             }
@@ -589,11 +729,11 @@ public final class ChunkEntitySlices {
                         continue;
                     }
 
-                    if (predicate != null && !predicate.test((T)entity)) {
+                    if (predicate != null && !predicate.test((T) entity)) {
                         continue;
                     }
 
-                    into.add((T)entity);
+                    into.add((T) entity);
                 }
             }
         }
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentArrayDeque.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentArrayDeque.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c29129dc02ddcfaad026d1f81e5da879a0d64cb
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentArrayDeque.java
@@ -0,0 +1,4 @@
+package net.himeki.mcmtfabric.parallelised;
+
+public class ConcurrentArrayDeque {
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java
new file mode 100644
index 0000000000000000000000000000000000000000..67dd5fe624fe4428d8907000cb23a33485fd6bd9
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java
@@ -0,0 +1,41 @@
+package net.himeki.mcmtfabric.parallelised;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+
+public class ConcurrentCollections {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public static <T> Set<T> newHashSet() {
+        //LOGGER.info("Concurrent hash set created");
+        return Collections.newSetFromMap(new ConcurrentHashMap<T, Boolean>());
+    }
+
+    public static <T, U> Map<T, U> newHashMap() {
+        //LOGGER.info("Concurrent hash map created");
+        return new ConcurrentHashMap<T, U>();
+    }
+
+    public static <T> List<T> newLinkedList() {
+        LOGGER.info("Concurrent \"linked\" list created");
+        return new CopyOnWriteArrayList<T>();
+    }
+
+    public static <T> Collector<T, ?, List<T>> toList() {
+        return Collectors.toCollection(CopyOnWriteArrayList::new);
+    }
+
+    public static <T> Queue<T> newArrayDeque() {
+        LOGGER.info("Concurrent \"array\" deque created");
+        return new ConcurrentLinkedDeque<T>();
+    }
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java
new file mode 100644
index 0000000000000000000000000000000000000000..fec1f280c72c5b519173017877812ec3f7149ec5
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java
@@ -0,0 +1,937 @@
+package net.himeki.mcmtfabric.parallelised;
+
+/*
+ * From: http://www.java2s.com/Code/Java/Collections-Data-Structure/ConcurrentDoublyLinkedList.htm
+ *
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/licenses/publicdomain
+ *
+ * Modified to actually implement List<E>
+ */
+
+import org.apache.commons.lang3.NotImplementedException;
+
+import java.util.*;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * A concurrent linked-list implementation of a {@link Deque} (double-ended
+ * queue). Concurrent insertion, removal, and access operations execute safely
+ * across multiple threads. Iterators are <i>weakly consistent</i>, returning
+ * elements reflecting the state of the deque at some point at or since the
+ * creation of the iterator. They do <em>not</em> throw
+ * {@link ConcurrentModificationException}, and may proceed concurrently with
+ * other operations.
+ *
+ * <p>
+ * This class and its iterators implement all of the <em>optional</em> methods
+ * of the {@link Collection} and {@link Iterator} interfaces. Like most other
+ * concurrent collection implementations, this class does not permit the use of
+ * <tt>null</tt> elements. because some null arguments and return values cannot
+ * be reliably distinguished from the absence of elements. Arbitrarily, the
+ * {@link Collection#remove} method is mapped to <tt>removeFirstOccurrence</tt>,
+ * and {@link Collection#add} is mapped to <tt>addLast</tt>.
+ *
+ * <p>
+ * Beware that, unlike in most collections, the <tt>size</tt> method is
+ * <em>NOT</em> a constant-time operation. Because of the asynchronous nature of
+ * these deques, determining the current number of elements requires a traversal
+ * of the elements.
+ *
+ * <p>
+ * This class is <tt>Serializable</tt>, but relies on default serialization
+ * mechanisms. Usually, it is a better idea for any serializable class using a
+ * <tt>ConcurrentLinkedDeque</tt> to instead serialize a snapshot of the
+ * elements obtained by method <tt>toArray</tt>.
+ *
+ * @author Doug Lea
+ * @param <E> the type of elements held in this collection
+ */
+
+public class ConcurrentDoublyLinkedList<E> extends AbstractCollection<E> implements List<E>, java.io.Serializable {
+
+    /*
+     * This is an adaptation of an algorithm described in Paul Martin's "A Practical
+     * Lock-Free Doubly-Linked List". Sun Labs Tech report. The basic idea is to
+     * primarily rely on next-pointers to ensure consistency. Prev-pointers are in
+     * part optimistic, reconstructed using forward pointers as needed. The main
+     * forward list uses a variant of HM-list algorithm similar to the one used in
+     * ConcurrentSkipListMap class, but a little simpler. It is also basically
+     * similar to the approach in Edya Ladan-Mozes and Nir Shavit "An Optimistic
+     * Approach to Lock-Free FIFO Queues" in DISC04.
+     *
+     * Quoting a summary in Paul Martin's tech report:
+     *
+     * All cleanups work to maintain these invariants: (1) forward pointers are the
+     * ground truth. (2) forward pointers to dead nodes can be improved by swinging
+     * them further forward around the dead node. (2.1) forward pointers are still
+     * correct when pointing to dead nodes, and forward pointers from dead nodes are
+     * left as they were when the node was deleted. (2.2) multiple dead nodes may
+     * point forward to the same node. (3) backward pointers were correct when they
+     * were installed (3.1) backward pointers are correct when pointing to any node
+     * which points forward to them, but since more than one forward pointer may
+     * point to them, the live one is best. (4) backward pointers that are out of
+     * date due to deletion point to a deleted node, and need to point further back
+     * until they point to the live node that points to their source. (5) backward
+     * pointers that are out of date due to insertion point too far backwards, so
+     * shortening their scope (by searching forward) fixes them. (6) backward
+     * pointers from a dead node cannot be "improved" since there may be no live
+     * node pointing forward to their origin. (However, it does no harm to try to
+     * improve them while racing with a deletion.)
+     *
+     *
+     * Notation guide for local variables n, b, f : a node, its predecessor, and
+     * successor s : some other successor
+     */
+
+    // Minor convenience utilities
+
+    /**
+     * Returns true if given reference is non-null and isn't a header, trailer, or
+     * marker.
+     *
+     * @param n (possibly null) node
+     * @return true if n exists as a user node
+     */
+    private static boolean usable(Node<?> n) {
+        return n != null && !n.isSpecial();
+    }
+
+    /**
+     * Throws NullPointerException if argument is null
+     *
+     * @param v the element
+     */
+    private static void checkNullArg(Object v) {
+        if (v == null)
+            throw new NullPointerException();
+    }
+
+    /**
+     * Returns element unless it is null, in which case throws
+     * NoSuchElementException.
+     *
+     * @param v the element
+     * @return the element
+     */
+    private E screenNullResult(E v) {
+        if (v == null)
+            throw new NoSuchElementException();
+        return v;
+    }
+
+    /**
+     * Creates an array list and fills it with elements of this list. Used by
+     * toArray.
+     *
+     * @return the arrayList
+     */
+    private ArrayList<E> toArrayList() {
+        ArrayList<E> c = new ArrayList<E>();
+        for (Node<E> n = header.forward(); n != null; n = n.forward())
+            c.add(n.element);
+        return c;
+    }
+
+    // Fields and constructors
+
+    private static final long serialVersionUID = 876323262645176354L;
+
+    /**
+     * List header. First usable node is at header.forward().
+     */
+    private final Node<E> header;
+
+    /**
+     * List trailer. Last usable node is at trailer.back().
+     */
+    private final Node<E> trailer;
+
+    /**
+     * Constructs an empty deque.
+     */
+    public ConcurrentDoublyLinkedList() {
+        Node<E> h = new Node<E>(null, null, null);
+        Node<E> t = new Node<E>(null, null, h);
+        h.setNext(t);
+        header = h;
+        trailer = t;
+    }
+
+    /**
+     * Constructs a deque containing the elements of the specified collection, in
+     * the order they are returned by the collection's iterator.
+     *
+     * @param c the collection whose elements are to be placed into this deque.
+     * @throws NullPointerException if <tt>c</tt> or any element within it is
+     *                              <tt>null</tt>
+     */
+    public ConcurrentDoublyLinkedList(Collection<? extends E> c) {
+        this();
+        addAll(c);
+    }
+
+    /**
+     * Prepends the given element at the beginning of this deque.
+     *
+     * @param o the element to be inserted at the beginning of this deque.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public void addFirst(E o) {
+        checkNullArg(o);
+        while (header.append(o) == null)
+            ;
+    }
+
+    /**
+     * Appends the given element to the end of this deque. This is identical in
+     * function to the <tt>add</tt> method.
+     *
+     * @param o the element to be inserted at the end of this deque.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public void addLast(E o) {
+        checkNullArg(o);
+        while (trailer.prepend(o) == null)
+            ;
+    }
+
+    /**
+     * Prepends the given element at the beginning of this deque.
+     *
+     * @param o the element to be inserted at the beginning of this deque.
+     * @return <tt>true</tt> always
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean offerFirst(E o) {
+        addFirst(o);
+        return true;
+    }
+
+    /**
+     * Appends the given element to the end of this deque. (Identical in function to
+     * the <tt>add</tt> method; included only for consistency.)
+     *
+     * @param o the element to be inserted at the end of this deque.
+     * @return <tt>true</tt> always
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean offerLast(E o) {
+        addLast(o);
+        return true;
+    }
+
+    /**
+     * Retrieves, but does not remove, the first element of this deque, or returns
+     * null if this deque is empty.
+     *
+     * @return the first element of this queue, or <tt>null</tt> if empty.
+     */
+    public E peekFirst() {
+        Node<E> n = header.successor();
+        return (n == null) ? null : n.element;
+    }
+
+    /**
+     * Retrieves, but does not remove, the last element of this deque, or returns
+     * null if this deque is empty.
+     *
+     * @return the last element of this deque, or <tt>null</tt> if empty.
+     */
+    public E peekLast() {
+        Node<E> n = trailer.predecessor();
+        return (n == null) ? null : n.element;
+    }
+
+    /**
+     * Returns the first element in this deque.
+     *
+     * @return the first element in this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E getFirst() {
+        return screenNullResult(peekFirst());
+    }
+
+    /**
+     * Returns the last element in this deque.
+     *
+     * @return the last element in this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E getLast() {
+        return screenNullResult(peekLast());
+    }
+
+    /**
+     * Retrieves and removes the first element of this deque, or returns null if
+     * this deque is empty.
+     *
+     * @return the first element of this deque, or <tt>null</tt> if empty.
+     */
+    public E pollFirst() {
+        for (;;) {
+            Node<E> n = header.successor();
+            if (!usable(n))
+                return null;
+            if (n.delete())
+                return n.element;
+        }
+    }
+
+    /**
+     * Retrieves and removes the last element of this deque, or returns null if this
+     * deque is empty.
+     *
+     * @return the last element of this deque, or <tt>null</tt> if empty.
+     */
+    public E pollLast() {
+        for (;;) {
+            Node<E> n = trailer.predecessor();
+            if (!usable(n))
+                return null;
+            if (n.delete())
+                return n.element;
+        }
+    }
+
+    /**
+     * Removes and returns the first element from this deque.
+     *
+     * @return the first element from this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E removeFirst() {
+        return screenNullResult(pollFirst());
+    }
+
+    /**
+     * Removes and returns the last element from this deque.
+     *
+     * @return the last element from this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E removeLast() {
+        return screenNullResult(pollLast());
+    }
+
+    // *** Queue and stack methods ***
+    public boolean offer(E e) {
+        return offerLast(e);
+    }
+
+    public boolean add(E e) {
+        return offerLast(e);
+    }
+
+    public E poll() {
+        return pollFirst();
+    }
+
+    public E remove() {
+        return removeFirst();
+    }
+
+    public E peek() {
+        return peekFirst();
+    }
+
+    public E element() {
+        return getFirst();
+    }
+
+    public void push(E e) {
+        addFirst(e);
+    }
+
+    public E pop() {
+        return removeFirst();
+    }
+
+    /**
+     * Removes the first element <tt>e</tt> such that <tt>o.equals(e)</tt>, if such
+     * an element exists in this deque. If the deque does not contain the element,
+     * it is unchanged.
+     *
+     * @param o element to be removed from this deque, if present.
+     * @return <tt>true</tt> if the deque contained the specified element.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean removeFirstOccurrence(Object o) {
+        checkNullArg(o);
+        for (;;) {
+            Node<E> n = header.forward();
+            for (;;) {
+                if (n == null)
+                    return false;
+                if (o.equals(n.element)) {
+                    if (n.delete())
+                        return true;
+                    else
+                        break; // restart if interference
+                }
+                n = n.forward();
+            }
+        }
+    }
+
+    /**
+     * Removes the last element <tt>e</tt> such that <tt>o.equals(e)</tt>, if such
+     * an element exists in this deque. If the deque does not contain the element,
+     * it is unchanged.
+     *
+     * @param o element to be removed from this deque, if present.
+     * @return <tt>true</tt> if the deque contained the specified element.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean removeLastOccurrence(Object o) {
+        checkNullArg(o);
+        for (;;) {
+            Node<E> s = trailer;
+            for (;;) {
+                Node<E> n = s.back();
+                if (s.isDeleted() || (n != null && n.successor() != s))
+                    break; // restart if pred link is suspect.
+                if (n == null)
+                    return false;
+                if (o.equals(n.element)) {
+                    if (n.delete())
+                        return true;
+                    else
+                        break; // restart if interference
+                }
+                s = n;
+            }
+        }
+    }
+
+    /**
+     * Returns <tt>true</tt> if this deque contains at least one element <tt>e</tt>
+     * such that <tt>o.equals(e)</tt>.
+     *
+     * @param o element whose presence in this deque is to be tested.
+     * @return <tt>true</tt> if this deque contains the specified element.
+     */
+    public boolean contains(Object o) {
+        if (o == null)
+            return false;
+        for (Node<E> n = header.forward(); n != null; n = n.forward())
+            if (o.equals(n.element))
+                return true;
+        return false;
+    }
+
+    /**
+     * Returns <tt>true</tt> if this collection contains no elements.
+     * <p>
+     *
+     * @return <tt>true</tt> if this collection contains no elements.
+     */
+    public boolean isEmpty() {
+        return !usable(header.successor());
+    }
+
+    /**
+     * Returns the number of elements in this deque. If this deque contains more
+     * than <tt>Integer.MAX_VALUE</tt> elements, it returns
+     * <tt>Integer.MAX_VALUE</tt>.
+     *
+     * <p>
+     * Beware that, unlike in most collections, this method is <em>NOT</em> a
+     * constant-time operation. Because of the asynchronous nature of these deques,
+     * determining the current number of elements requires traversing them all to
+     * count them. Additionally, it is possible for the size to change during
+     * execution of this method, in which case the returned result will be
+     * inaccurate. Thus, this method is typically not very useful in concurrent
+     * applications.
+     *
+     * @return the number of elements in this deque.
+     */
+    public int size() {
+        long count = 0;
+        for (Node<E> n = header.forward(); n != null; n = n.forward())
+            ++count;
+        return (count >= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) count;
+    }
+
+    /**
+     * Removes the first element <tt>e</tt> such that <tt>o.equals(e)</tt>, if such
+     * an element exists in this deque. If the deque does not contain the element,
+     * it is unchanged.
+     *
+     * @param o element to be removed from this deque, if present.
+     * @return <tt>true</tt> if the deque contained the specified element.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean remove(Object o) {
+        return removeFirstOccurrence(o);
+    }
+
+    /**
+     * Appends all of the elements in the specified collection to the end of this
+     * deque, in the order that they are returned by the specified collection's
+     * iterator. The behavior of this operation is undefined if the specified
+     * collection is modified while the operation is in progress. (This implies that
+     * the behavior of this call is undefined if the specified Collection is this
+     * deque, and this deque is nonempty.)
+     *
+     * @param c the elements to be inserted into this deque.
+     * @return <tt>true</tt> if this deque changed as a result of the call.
+     * @throws NullPointerException if <tt>c</tt> or any element within it is
+     *                              <tt>null</tt>
+     */
+    public boolean addAll(Collection<? extends E> c) {
+        Iterator<? extends E> it = c.iterator();
+        if (!it.hasNext())
+            return false;
+        do {
+            addLast(it.next());
+        } while (it.hasNext());
+        return true;
+    }
+
+    /**
+     * Removes all of the elements from this deque.
+     */
+    public void clear() {
+        while (pollFirst() != null)
+            ;
+    }
+
+    /**
+     * Returns an array containing all of the elements in this deque in the correct
+     * order.
+     *
+     * @return an array containing all of the elements in this deque in the correct
+     *         order.
+     */
+    public Object[] toArray() {
+        return toArrayList().toArray();
+    }
+
+    /**
+     * Returns an array containing all of the elements in this deque in the correct
+     * order; the runtime type of the returned array is that of the specified array.
+     * If the deque fits in the specified array, it is returned therein. Otherwise,
+     * a new array is allocated with the runtime type of the specified array and the
+     * size of this deque.
+     * <p>
+     *
+     * If the deque fits in the specified array with room to spare (i.e., the array
+     * has more elements than the deque), the element in the array immediately
+     * following the end of the collection is set to null. This is useful in
+     * determining the length of the deque <i>only</i> if the caller knows that the
+     * deque does not contain any null elements.
+     *
+     * @param a the array into which the elements of the deque are to be stored, if
+     *          it is big enough; otherwise, a new array of the same runtime type is
+     *          allocated for this purpose.
+     * @return an array containing the elements of the deque.
+     * @throws ArrayStoreException  if the runtime type of a is not a supertype of
+     *                              the runtime type of every element in this deque.
+     * @throws NullPointerException if the specified array is null.
+     */
+    public <T> T[] toArray(T[] a) {
+        return toArrayList().toArray(a);
+    }
+
+    /**
+     * Returns a weakly consistent iterator over the elements in this deque, in
+     * first-to-last order. The <tt>next</tt> method returns elements reflecting the
+     * state of the deque at some point at or since the creation of the iterator.
+     * The method does <em>not</em> throw {@link ConcurrentModificationException},
+     * and may proceed concurrently with other operations.
+     *
+     * @return an iterator over the elements in this deque
+     */
+    public Iterator<E> iterator() {
+        return new CLDIterator();
+    }
+
+    final class CLDIterator implements Iterator<E> {
+        Node<E> last;
+
+        Node<E> next = header.forward();
+
+        public boolean hasNext() {
+            return next != null;
+        }
+
+        public E next() {
+            Node<E> l = last = next;
+            if (l == null)
+                throw new NoSuchElementException();
+            next = next.forward();
+            return l.element;
+        }
+
+        public void remove() {
+            Node<E> l = last;
+            if (l == null)
+                throw new IllegalStateException();
+            while (!l.delete() && !l.isDeleted())
+                ;
+        }
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends E> c) {
+        throw new NotImplementedException("TODO");
+    }
+
+    @Override
+    public E get(int index) {
+        Node<E> current = header.successor();
+        if (current == null) {
+            throw new IndexOutOfBoundsException();
+        }
+        for (; index > 0; index --) {
+            current = current.successor();
+            if (current == null) {
+                throw new IndexOutOfBoundsException();
+            }
+        }
+        return current.element;
+    }
+
+    @Override
+    public E set(int index, E element) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public void add(int index, E element) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public E remove(int index) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public ListIterator<E> listIterator() {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public ListIterator<E> listIterator(int index) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public List<E> subList(int fromIndex, int toIndex) {
+        throw new NotImplementedException("INVALID");
+    }
+
+}
+
+/**
+ * Linked Nodes. As a minor efficiency hack, this class opportunistically
+ * inherits from AtomicReference, with the atomic ref used as the "next" link.
+ *
+ * Nodes are in doubly-linked lists. There are three kinds of special nodes,
+ * distinguished by: * The list header has a null prev link * The list trailer
+ * has a null next link * A deletion marker has a prev link pointing to itself.
+ * All three kinds of special nodes have null element fields.
+ *
+ * Regular nodes have non-null element, next, and prev fields. To avoid visible
+ * inconsistencies when deletions overlap element replacement, replacements are
+ * done by replacing the node, not just setting the element.
+ *
+ * Nodes can be traversed by read-only ConcurrentLinkedDeque class operations
+ * just by following raw next pointers, so long as they ignore any special nodes
+ * seen along the way. (This is automated in method forward.) However, traversal
+ * using prev pointers is not guaranteed to see all live nodes since a prev
+ * pointer of a deleted node can become unrecoverably stale.
+ */
+
+class Node<E> extends AtomicReference<Node<E>> {
+
+    private static final long serialVersionUID = 6640557564507962862L;
+
+    private volatile Node<E> prev;
+
+    final E element;
+
+    /** Creates a node with given contents */
+    Node(E element, Node<E> next, Node<E> prev) {
+        super(next);
+        this.prev = prev;
+        this.element = element;
+    }
+
+    /** Creates a marker node with given successor */
+    Node(Node<E> next) {
+        super(next);
+        this.prev = this;
+        this.element = null;
+    }
+
+    /**
+     * Gets next link (which is actually the value held as atomic reference).
+     */
+    private Node<E> getNext() {
+        return get();
+    }
+
+    /**
+     * Sets next link
+     *
+     * @param n the next node
+     */
+    void setNext(Node<E> n) {
+        set(n);
+    }
+
+    /**
+     * compareAndSet next link
+     */
+    private boolean casNext(Node<E> cmp, Node<E> val) {
+        return compareAndSet(cmp, val);
+    }
+
+    /**
+     * Gets prev link
+     */
+    private Node<E> getPrev() {
+        return prev;
+    }
+
+    /**
+     * Sets prev link
+     *
+     * @param b the previous node
+     */
+    void setPrev(Node<E> b) {
+        prev = b;
+    }
+
+    /**
+     * Returns true if this is a header, trailer, or marker node
+     */
+    boolean isSpecial() {
+        return element == null;
+    }
+
+    /**
+     * Returns true if this is a trailer node
+     */
+    boolean isTrailer() {
+        return getNext() == null;
+    }
+
+    /**
+     * Returns true if this is a header node
+     */
+    boolean isHeader() {
+        return getPrev() == null;
+    }
+
+    /**
+     * Returns true if this is a marker node
+     */
+    boolean isMarker() {
+        return getPrev() == this;
+    }
+
+    /**
+     * Returns true if this node is followed by a marker, meaning that it is
+     * deleted.
+     *
+     * @return true if this node is deleted
+     */
+    boolean isDeleted() {
+        Node<E> f = getNext();
+        return f != null && f.isMarker();
+    }
+
+    /**
+     * Returns next node, ignoring deletion marker
+     */
+    private Node<E> nextNonmarker() {
+        Node<E> f = getNext();
+        return (f == null || !f.isMarker()) ? f : f.getNext();
+    }
+
+    /**
+     * Returns the next non-deleted node, swinging next pointer around any
+     * encountered deleted nodes, and also patching up successor''s prev link to
+     * point back to this. Returns null if this node is trailer so has no successor.
+     *
+     * @return successor, or null if no such
+     */
+    Node<E> successor() {
+        Node<E> f = nextNonmarker();
+        for (;;) {
+            if (f == null)
+                return null;
+            if (!f.isDeleted()) {
+                if (f.getPrev() != this && !isDeleted())
+                    f.setPrev(this); // relink f's prev
+                return f;
+            }
+            Node<E> s = f.nextNonmarker();
+            if (f == getNext())
+                casNext(f, s); // unlink f
+            f = s;
+        }
+    }
+
+    /**
+     * Returns the apparent predecessor of target by searching forward for it
+     * starting at this node, patching up pointers while traversing. Used by
+     * predecessor().
+     *
+     * @return target's predecessor, or null if not found
+     */
+    private Node<E> findPredecessorOf(Node<E> target) {
+        Node<E> n = this;
+        for (;;) {
+            Node<E> f = n.successor();
+            if (f == target)
+                return n;
+            if (f == null)
+                return null;
+            n = f;
+        }
+    }
+
+    /**
+     * Returns the previous non-deleted node, patching up pointers as needed.
+     * Returns null if this node is header so has no successor. May also return null
+     * if this node is deleted, so doesn't have a distinct predecessor.
+     *
+     * @return predecessor or null if not found
+     */
+    Node<E> predecessor() {
+        Node<E> n = this;
+        for (;;) {
+            Node<E> b = n.getPrev();
+            if (b == null)
+                return n.findPredecessorOf(this);
+            Node<E> s = b.getNext();
+            if (s == this)
+                return b;
+            if (s == null || !s.isMarker()) {
+                Node<E> p = b.findPredecessorOf(this);
+                if (p != null)
+                    return p;
+            }
+            n = b;
+        }
+    }
+
+    /**
+     * Returns the next node containing a nondeleted user element. Use for forward
+     * list traversal.
+     *
+     * @return successor, or null if no such
+     */
+    Node<E> forward() {
+        Node<E> f = successor();
+        return (f == null || f.isSpecial()) ? null : f;
+    }
+
+    /**
+     * Returns previous node containing a nondeleted user element, if possible. Use
+     * for backward list traversal, but beware that if this method is called from a
+     * deleted node, it might not be able to determine a usable predecessor.
+     *
+     * @return predecessor, or null if no such could be found
+     */
+    Node<E> back() {
+        Node<E> f = predecessor();
+        return (f == null || f.isSpecial()) ? null : f;
+    }
+
+    /**
+     * Tries to insert a node holding element as successor, failing if this node is
+     * deleted.
+     *
+     * @param element the element
+     * @return the new node, or null on failure.
+     */
+    Node<E> append(E element) {
+        for (;;) {
+            Node<E> f = getNext();
+            if (f == null || f.isMarker())
+                return null;
+            Node<E> x = new Node<E>(element, f, this);
+            if (casNext(f, x)) {
+                f.setPrev(x); // optimistically link
+                return x;
+            }
+        }
+    }
+
+    /**
+     * Tries to insert a node holding element as predecessor, failing if no live
+     * predecessor can be found to link to.
+     *
+     * @param element the element
+     * @return the new node, or null on failure.
+     */
+    Node<E> prepend(E element) {
+        for (;;) {
+            Node<E> b = predecessor();
+            if (b == null)
+                return null;
+            Node<E> x = new Node<E>(element, this, b);
+            if (b.casNext(this, x)) {
+                setPrev(x); // optimistically link
+                return x;
+            }
+        }
+    }
+
+    /**
+     * Tries to mark this node as deleted, failing if already deleted or if this
+     * node is header or trailer
+     *
+     * @return true if successful
+     */
+    boolean delete() {
+        Node<E> b = getPrev();
+        Node<E> f = getNext();
+        if (b != null && f != null && !f.isMarker() && casNext(f, new Node<E>(f))) {
+            if (b.casNext(this, f))
+                f.setPrev(b);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Tries to insert a node holding element to replace this node. failing if
+     * already deleted.
+     *
+     * @param newElement the new element
+     * @return the new node, or null on failure.
+     */
+    Node<E> replace(E newElement) {
+        for (;;) {
+            Node<E> b = getPrev();
+            Node<E> f = getNext();
+            if (b == null || f == null || f.isMarker())
+                return null;
+            Node<E> x = new Node<E>(newElement, f, b);
+            if (casNext(f, new Node<E>(x))) {
+                b.successor(); // to relink b
+                x.successor(); // to relink f
+                return x;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..586b3c87dcf010e2401933c5ec2338f59b9edad3
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java
@@ -0,0 +1,230 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.*;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+public class ConcurrentLongLinkedOpenHashSet extends LongLinkedOpenHashSet {
+
+    private static final long serialVersionUID = -5532128240738069111L;
+
+    private final ConcurrentSkipListSet<Long> backing;
+
+    public ConcurrentLongLinkedOpenHashSet() {
+        //backing = new ConcurrentLinkedDeque<Long>();
+        backing = new ConcurrentSkipListSet<Long>();
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final int initial) {
+        //backing = new ConcurrentLinkedDeque<Long>();
+        backing = new ConcurrentSkipListSet<Long>();
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final int initial, final float dnc) {
+        this(initial);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongCollection c) {
+        this(c.size());
+        addAll(c);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongCollection c, final float f) {
+        this(c.size(), f);
+        addAll(c);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongIterator i, final float f) {
+        this(16, f);
+        while (i.hasNext())
+            add(i.nextLong());
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongIterator i) {
+        this(i, -1);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final Iterator<?> i, final float f) {
+        this(LongIterators.asLongIterator(i), f);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final Iterator<?> i) {
+        this(LongIterators.asLongIterator(i));
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final int offset, final int length, final float f) {
+        this(length < 0 ? 0 : length, f);
+        LongArrays.ensureOffsetLength(a, offset, length);
+        for (int i = 0; i < length; i++)
+            add(a[offset + i]);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final int offset, final int length) {
+        this(a, offset, length, DEFAULT_LOAD_FACTOR);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final float f) {
+        this(a, 0, a.length, f);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a) {
+        this(a, -1);
+    }
+
+    @Override
+    public boolean add(final long k) {
+        boolean out = backing.add(k);
+		/*
+		if (!firstDef) {
+			first = k;
+			firstDef = true;
+		}
+		last = k;
+		*/
+        return out;
+    }
+
+    @Override
+    public boolean addAll(LongCollection c) {
+        return addAll((Collection<Long>) c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends Long> c) {
+        return backing.addAll(c);
+    }
+
+    @Override
+    public boolean addAndMoveToFirst(final long k) {
+        boolean out = backing.add(k);
+        //first = k;
+        return out;
+    }
+
+    @Override
+    public boolean addAndMoveToLast(final long k) {
+        boolean out = backing.add(k);
+        //last = k;
+        return out;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public LongLinkedOpenHashSet clone() {
+        return new ConcurrentLongLinkedOpenHashSet(backing.iterator());
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+    @Override
+    public boolean contains(final long k) {
+        return backing.contains(k);
+    }
+
+    @Override
+    public long firstLong() {
+		/*
+		if (backing.size() == 0) throw new NoSuchElementException();
+		return first;
+		*/
+        return backing.first();
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public LongSortedSet headSet(long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public LongListIterator iterator() {
+        return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public LongListIterator iterator(long from) {
+        throw new IllegalStateException();
+        //return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public long lastLong() {
+		/*
+		if (backing.size() == 0) throw new NoSuchElementException();
+		return last;
+		*/
+        return backing.last();
+    }
+
+    @Override
+    public boolean remove(final long k) {
+		/*
+		if (k == first) {
+			first = backing.iterator().next();
+		}
+		if (k == last) {
+			last = backing.iterator().next();
+		}
+		*/
+        return backing.remove(k);
+    }
+
+    @Override
+    public long removeFirstLong() {
+        long fl = this.firstLong();
+        this.remove(fl);
+        //first = backing.iterator().next();
+        return fl;
+    }
+
+    @Override
+    public long removeLastLong() {
+        long fl = this.lastLong();
+        this.remove(fl);
+        //last = backing.iterator().next();
+        return fl;
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public LongSortedSet subSet(long from, long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongSortedSet tailSet(long from) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean trim() {
+        return true;
+    }
+
+    @Override
+    public boolean trim(final int n) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongSortedSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongSortedSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..93bd066ec2013e42a85fcf21344fe41f3ad69598
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongSortedSet.java
@@ -0,0 +1,144 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.*;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+public class ConcurrentLongSortedSet implements LongSortedSet {
+
+    ConcurrentSkipListSet<Long> back = new ConcurrentSkipListSet<>();
+
+    @Override
+    public LongBidirectionalIterator iterator(long fromElement) {
+        return null;
+    }
+
+    @Override
+    public int size() {
+        return back.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return back.isEmpty();
+    }
+
+    @Override
+    public LongBidirectionalIterator iterator() {
+        return null;
+    }
+
+    @NotNull
+    @Override
+    public Object[] toArray() {
+        return back.toArray();
+    }
+
+    @NotNull
+    @Override
+    public <T> T[] toArray(@NotNull T[] ts) {
+        return null;
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> collection) {
+        return back.containsAll(collection);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends Long> collection) {
+        return back.addAll(collection);
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> collection) {
+        return back.removeAll(collection);
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> collection) {
+        return back.retainAll(collection);
+    }
+
+    @Override
+    public void clear() {
+        back.clear();
+    }
+
+    @Override
+    public boolean add(long key) {
+        return back.add(key);
+    }
+
+    @Override
+    public boolean contains(long key) {
+        return back.contains(key);
+    }
+
+    @Override
+    public long[] toLongArray() {
+        return new long[0];
+    }
+
+    @Override
+    public long[] toArray(long[] a) {
+        return new long[0];
+    }
+
+    @Override
+    public boolean addAll(LongCollection c) {
+        return back.addAll(c);
+    }
+
+    @Override
+    public boolean containsAll(LongCollection c) {
+        return back.containsAll(c);
+    }
+
+    @Override
+    public boolean removeAll(LongCollection c) {
+        return back.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(LongCollection c) {
+        return back.retainAll(c);
+    }
+
+    @Override
+    public boolean remove(long k) {
+        return back.remove(k);
+    }
+
+    @Override
+    public LongSortedSet subSet(long fromElement, long toElement) {
+        return new LongAVLTreeSet(back.subSet(fromElement,toElement));
+    }
+
+    @Override
+    public LongSortedSet headSet(long toElement) {
+        return new LongAVLTreeSet(back.headSet(toElement));
+    }
+
+    @Override
+    public LongSortedSet tailSet(long fromElement) {
+        return new LongAVLTreeSet(back.tailSet(fromElement));
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+    @Override
+    public long firstLong() {
+        return back.first();
+    }
+
+    @Override
+    public long lastLong() {
+        return back.last();
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff1a4f87356459d3bc990a77c3081932046da5b1
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java
@@ -0,0 +1,112 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.shorts.ShortCollection;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import it.unimi.dsi.fastutil.shorts.ShortSet;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ConcurrentShortHashSet implements ShortSet {
+
+    ConcurrentHashMap.KeySetView<Short, Boolean> backing = ConcurrentHashMap.newKeySet();
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public ShortIterator iterator() {
+        return new FastUtilHackUtil.WrappingShortIterator(backing.iterator());
+    }
+
+    @NotNull
+    @Override
+    public Object[] toArray() {
+        return backing.toArray();
+    }
+
+    @NotNull
+    @Override
+    public <T> T[] toArray(@NotNull T[] ts) {
+        return (T[]) backing.toArray();
+    }
+
+    @Override
+    public boolean containsAll(@NotNull Collection<?> collection) {
+        return backing.containsAll(collection);
+    }
+
+    @Override
+    public boolean addAll(@NotNull Collection<? extends Short> collection) {
+        return backing.addAll(collection);
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> collection) {
+        return backing.removeAll(collection);
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> collection) {
+        return backing.retainAll(collection);
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+
+    }
+
+    @Override
+    public boolean add(short key) {
+        return backing.add(key);
+    }
+
+    @Override
+    public boolean contains(short key) {
+        return backing.contains(key);
+    }
+
+    @Override
+    public short[] toShortArray() {
+        return new short[0];
+    }
+
+    @Override
+    public short[] toArray(short[] a) {
+        return new short[0];
+    }
+
+    @Override
+    public boolean addAll(ShortCollection c) {
+        return backing.addAll(c);
+    }
+
+    @Override
+    public boolean containsAll(ShortCollection c) {
+        return backing.containsAll(c);
+    }
+
+    @Override
+    public boolean removeAll(ShortCollection c) {
+        return backing.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(ShortCollection c) {
+        return backing.retainAll(c);
+    }
+
+    @Override
+    public boolean remove(short k) {
+        return backing.remove(k);
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca1fd9ca6f5c5d5d4a0f374440ccaf80347fb781
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java
@@ -0,0 +1,1678 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.bytes.ByteIterator;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.ints.IntIterator;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.longs.*;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import org.apache.commons.lang3.ArrayUtils;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public class FastUtilHackUtil {
+
+    public static class ConvertingObjectSet<E, T> implements ObjectSet<T> {
+
+        Set<E> backing;
+        Function<E, T> forward;
+        Function<T, E> back;
+
+        public ConvertingObjectSet(Set<E> backing, Function<E, T> forward, Function<T, E> back) {
+            this.backing = backing;
+            this.forward = forward;
+            this.back = back;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+        @Override
+        public boolean add(T e) {
+            return backing.add(back.apply(e));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends T> c) {
+            return backing.addAll(c.stream().map(i -> back.apply(i)).collect(Collectors.toSet()));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+
+        }
+
+        @Override
+        public ObjectIterator<T> iterator() {
+            final Iterator<E> backg = backing.iterator();
+            return new ObjectIterator<T>() {
+
+                @Override
+                public boolean hasNext() {
+                    return backg.hasNext();
+                }
+
+                @Override
+                public T next() {
+                    return forward.apply(backg.next());
+                }
+
+                @Override
+                public void remove() {
+                    backg.remove();
+                }
+            };
+        }
+
+
+    }
+
+    public static class ConvertingObjectSetFast<E,T> implements Long2ObjectMap.FastEntrySet<T> {
+
+        Set<E> backing;
+        Function<E, Long2ObjectMap.Entry<T>> forward;
+        Function<Long2ObjectMap.Entry<T>, E> back;
+
+        public ConvertingObjectSetFast(Set<E> backing,
+                                       Function<E, Long2ObjectMap.Entry<T>> forward,
+                                       Function<Long2ObjectMap.Entry<T>, E> back) {
+            this.backing = backing;
+            this.forward = forward;
+            this.back = back;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((Long2ObjectMap.Entry<T>)o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((Long2ObjectMap.Entry<T>)o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream()
+                        .map(i -> back.apply((Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream().map(i -> back
+                                .apply((Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream()
+                        .map(i -> back.apply((Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+
+        }
+
+        @Override
+        public ObjectIterator<Long2ObjectMap.Entry<T>> iterator() {
+            final Iterator<E> backg = backing.iterator();
+            return new ObjectIterator<Long2ObjectMap.Entry<T>>() {
+
+                @Override
+                public boolean hasNext() {
+                    return backg.hasNext();
+                }
+
+                @Override
+                public Long2ObjectMap.Entry<T> next() {
+                    return forward.apply(backg.next());
+                }
+
+                @Override
+                public void remove() {
+                    backg.remove();
+                }
+            };
+        }
+
+        @Override
+        public boolean add(Long2ObjectMap.Entry<T> e) {
+            return backing.add(back.apply(e));
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long2ObjectMap.Entry<T>> c) {
+            return backing.addAll(c.stream().map(back).collect(Collectors.toList()));
+        }
+
+        @Override
+        public ObjectIterator<Long2ObjectMap.Entry<T>> fastIterator() {
+            return iterator();
+        }
+
+
+    }
+
+    private static <T> Entry<T> intEntryForwards(Map.Entry<Integer, T> entry) {
+        return new Entry<T>() {
+
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public int getIntKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Integer, T> intEntryBackwards(Entry<T> entry) {
+        return entry;
+    }
+
+    private static <T> Long2ObjectMap.Entry<T> longEntryForwards(Map.Entry<Long, T> entry) {
+        return new Long2ObjectMap.Entry<T>() {
+
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Long, T> longEntryBackwards(Long2ObjectMap.Entry<T> entry) {
+        return entry;
+    }
+
+    private static Long2ByteMap.Entry longByteEntryForwards(Map.Entry<Long, Byte> entry) {
+        return new Long2ByteMap.Entry() {
+
+            @Override
+            public Byte getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public byte setValue(byte value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public byte getByteValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+
+        };
+    }
+
+    private static <T> Map.Entry<Long, Byte> longByteEntryBackwards(Long2ByteMap.Entry entry) {
+        return entry;
+    }
+
+    private static Long2LongMap.Entry longLongEntryForwards(Map.Entry<Long, Long> entry) {
+        return new Long2LongMap.Entry() {
+
+            @Override
+            public Long getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public long setValue(long value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public long getLongValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+
+        };
+    }
+
+    private static <T> Map.Entry<Long, Long> longLongEntryBackwards(Long2LongMap.Entry entry) {
+        return entry;
+    }
+
+    public static <T> ObjectSet<Entry<T>> entrySetIntWrap(Map<Integer, T> map) {
+        return new ConvertingObjectSet<Map.Entry<Integer, T>, Entry<T>>(map.entrySet(), FastUtilHackUtil::intEntryForwards, FastUtilHackUtil::intEntryBackwards);
+    }
+
+    public static <T> ObjectSet<Long2ObjectMap.Entry<T>> entrySetLongWrap(Map<Long, T> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, T>, Long2ObjectMap.Entry<T>>(map.entrySet(), FastUtilHackUtil::longEntryForwards, FastUtilHackUtil::longEntryBackwards);
+    }
+
+    public static <T> Long2ObjectMap.FastEntrySet<T> entrySetLongWrapFast(Map<Long, T> map) {
+        return new ConvertingObjectSetFast<Map.Entry<Long, T>, T>(map.entrySet(), FastUtilHackUtil::longEntryForwards, FastUtilHackUtil::longEntryBackwards);
+    }
+
+    public static ObjectSet<Long2ByteMap.Entry> entrySetLongByteWrap(Map<Long, Byte> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, Byte>, Long2ByteMap.Entry>(map.entrySet(), FastUtilHackUtil::longByteEntryForwards, FastUtilHackUtil::longByteEntryBackwards);
+    }
+
+    public static ObjectSet<Long2LongMap.Entry> entrySetLongLongWrap(Map<Long, Long> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, Long>, Long2LongMap.Entry>(map.entrySet(), FastUtilHackUtil::longLongEntryForwards, FastUtilHackUtil::longLongEntryBackwards);
+    }
+
+
+    static class WrappingIntIterator implements IntIterator {
+
+        Iterator<Integer> backing;
+
+        public WrappingIntIterator(Iterator<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public int nextInt() {
+            return backing.next();
+        }
+
+        @Override
+        public Integer next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    static class WrappingLongIterator implements LongIterator {
+
+        Iterator<Long> backing;
+
+        public WrappingLongIterator(Iterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public Long next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    static class WrappingShortIterator implements ShortIterator {
+
+        Iterator<Short> backing;
+
+        public WrappingShortIterator(Iterator<Short> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public short nextShort() {
+            return backing.next();
+        }
+
+        @Override
+        public Short next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    public static class WrappingIntSet implements IntSet {
+
+        Set<Integer> backing;
+
+        public WrappingIntSet(Set<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(int key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean contains(int key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return backing.stream().mapToInt(i -> i).toArray();
+        }
+
+        @Override
+        public int[] toIntArray(int[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toIntArray();
+            }
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return toIntArray(a);
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return new WrappingIntIterator(backing.iterator());
+        }
+
+        @Override
+        public boolean remove(int k) {
+            return backing.remove(k);
+        }
+
+    }
+
+    public static LongSet wrapLongSet(Set<Long> longset) {
+        return new WrappingLongSet(longset);
+    }
+
+    public static class WrappingLongSet implements LongSet {
+
+        Set<Long> backing;
+
+        public WrappingLongSet(Set<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(i -> i).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toLongArray();
+            }
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return new WrappingLongIterator(backing.iterator());
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+
+    }
+
+    public static LongSortedSet wrapLongSortedSet(Set<Long> longset) {
+        return new WrappingLongSortedSet(longset);
+    }
+
+    public static class WrappingLongSortedSet implements LongSortedSet {
+
+        Set<Long> backing;
+
+        public WrappingLongSortedSet(Set<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(i -> i).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toLongArray();
+            }
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator(long fromElement) {
+            throw new UnsupportedOperationException();
+            //return FastUtilHackUtil.wrap(new LinkedList<Long>(backing).iterator());
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator() {
+            return FastUtilHackUtil.wrap(new LinkedList<Long>(backing).iterator());
+        }
+
+        @Override
+        public LongSortedSet subSet(long fromElement, long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet headSet(long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet tailSet(long fromElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongComparator comparator() {
+            return null;
+        }
+
+        @Override
+        public long firstLong() {
+            return backing.stream().findAny().get();
+        }
+
+        @Override
+        public long lastLong() {
+            return backing.stream().findAny().get();
+        }
+
+    }
+
+    public static IntSet wrapIntSet(Set<Integer> intset) {
+        return new WrappingIntSet(intset);
+    }
+
+    public static class WrappingObjectCollection<V> implements ObjectCollection<V> {
+
+        Collection<V> backing;
+
+        public WrappingObjectCollection(Collection<V> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(V e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends V> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ObjectIterator<V> iterator() {
+            return FastUtilHackUtil.itrWrap(backing);
+        }
+
+    }
+
+    public static <K> ObjectCollection<K> wrap(Collection<K> c) {
+        return new WrappingObjectCollection<K>(c);
+    }
+
+    public static class WrappingByteCollection implements ByteCollection {
+
+        Collection<Byte> backing;
+
+        public WrappingByteCollection(Collection<Byte> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(byte o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(byte e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Byte> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ByteIterator iterator() {
+            return FastUtilHackUtil.itrByteWrap(backing);
+        }
+
+        @Override
+        public boolean rem(byte key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public byte[] toByteArray() {
+            return null;
+        }
+
+        @Override
+        public byte[] toByteArray(byte[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public byte[] toArray(byte[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Byte[0]));
+        }
+
+        @Override
+        public boolean addAll(ByteCollection c) {
+            return addAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean containsAll(ByteCollection c) {
+            return containsAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean removeAll(ByteCollection c) {
+            return removeAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean retainAll(ByteCollection c) {
+            return retainAll((Collection<Byte>) c);
+        }
+
+    }
+
+    public static ByteCollection wrapBytes(Collection<Byte> c) {
+        return new WrappingByteCollection(c);
+    }
+
+    public static class WrappingIntCollection implements IntCollection {
+
+        Collection<Integer> backing;
+
+        public WrappingIntCollection(Collection<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(int o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(int e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return FastUtilHackUtil.itrIntWrap(backing);
+        }
+
+        @Override
+        public boolean rem(int key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return null;
+        }
+
+        @Override
+        public int[] toIntArray(int[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Integer[0]));
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return addAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return containsAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return removeAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return retainAll((Collection<Integer>) c);
+        }
+
+    }
+
+    public static IntCollection wrapInts(Collection<Integer> c) {
+        return new WrappingIntCollection(c);
+    }
+
+    public static class WrappingLongCollection implements LongCollection {
+
+        Collection<Long> backing;
+
+        public WrappingLongCollection(Collection<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(long o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(long e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return FastUtilHackUtil.itrLongWrap(backing);
+        }
+
+        @Override
+        public boolean rem(long key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return null;
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Long[0]));
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return addAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return containsAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return removeAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return retainAll((Collection<Long>) c);
+        }
+
+    }
+
+    public static LongCollection wrapLongs(Collection<Long> c) {
+        return new WrappingLongCollection(c);
+    }
+
+
+    public static class WrappingLongListIterator implements LongListIterator {
+
+        ListIterator<Long> backing;
+
+        public WrappingLongListIterator(ListIterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public long previousLong() {
+            return backing.previous();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            return backing.hasPrevious();
+        }
+
+        @Override
+        public int nextIndex() {
+            return backing.nextIndex();
+        }
+
+        @Override
+        public int previousIndex() {
+            return backing.previousIndex();
+        }
+
+        @Override
+        public void add(long k) {
+            backing.add(k);
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(long k) {
+            backing.set(k);
+        }
+    }
+
+    public static class SlimWrappingLongListIterator implements LongListIterator {
+
+        Iterator<Long> backing;
+
+        public SlimWrappingLongListIterator(Iterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public long previousLong() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public int nextIndex() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public int previousIndex() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public void add(long k) {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(long k) {
+            throw new IllegalStateException();
+        }
+    }
+
+    public static LongListIterator wrap(ListIterator<Long> c) {
+        return new WrappingLongListIterator(c);
+    }
+
+    public static LongListIterator wrap(Iterator<Long> c) {
+        return new SlimWrappingLongListIterator(c);
+    }
+
+    public static class WrappingByteIterator implements ByteIterator {
+
+        Iterator<Byte> parent;
+
+        public WrappingByteIterator(Iterator<Byte> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public Byte next() {
+            return parent.next();
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+        @Override
+        public byte nextByte() {
+            return next();
+        }
+
+    }
+
+    public static ByteIterator itrByteWrap(Iterator<Byte> backing) {
+        return new WrappingByteIterator(backing);
+    }
+
+    public static ByteIterator itrByteWrap(Iterable<Byte> backing) {
+        return new WrappingByteIterator(backing.iterator());
+    }
+
+    public static IntIterator itrIntWrap(Iterator<Integer> backing) {
+        return new WrappingIntIterator(backing);
+    }
+
+    public static IntIterator itrIntWrap(Iterable<Integer> backing) {
+        return new WrappingIntIterator(backing.iterator());
+    }
+
+    public static LongIterator itrLongWrap(Iterator<Long> backing) {
+        return new WrappingLongIterator(backing);
+    }
+
+    public static LongIterator itrLongWrap(Iterable<Long> backing) {
+        return new WrappingLongIterator(backing.iterator());
+    }
+
+    public static ShortIterator itrShortWrap(Iterator<Short> backing) {
+        return new WrappingShortIterator(backing);
+    }
+
+    public static ShortIterator itrShortWrap(Iterable<Short> backing) {
+        return new WrappingShortIterator(backing.iterator());
+    }
+
+    public static class WrapperObjectIterator<T> implements ObjectIterator<T> {
+
+        Iterator<T> parent;
+
+        public WrapperObjectIterator(Iterator<T> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public T next() {
+            return parent.next();
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+    }
+
+    public static class IntWrapperEntry<T> implements Entry<T> {
+
+        Map.Entry<Integer, T> parent;
+
+        public IntWrapperEntry(Map.Entry<Integer, T> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public T getValue() {
+            return parent.getValue();
+        }
+
+        @Override
+        public T setValue(T value) {
+            return parent.setValue(value);
+        }
+
+        @Override
+        public int getIntKey() {
+            return parent.getKey();
+        }
+
+        @Override
+        public Integer getKey() {
+            return parent.getKey();
+        }
+
+    }
+
+    public static class Long2IntWrapperEntry implements Long2IntMap.Entry {
+
+        Map.Entry<Long, Integer> parent;
+
+        public Long2IntWrapperEntry(Map.Entry<Long, Integer> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public long getLongKey() {
+            return parent.getKey();
+        }
+
+        @Override
+        public int getIntValue() {
+            return parent.getValue();
+        }
+
+        @Override
+        public int setValue(int value) {
+            return parent.setValue(value);
+        }
+
+
+    }
+
+    public static class WrapperIntEntryObjectIterator<T> implements ObjectIterator<Entry<T>> {
+
+        Iterator<Map.Entry<Integer, T>> parent;
+
+        public WrapperIntEntryObjectIterator(Iterator<Map.Entry<Integer, T>> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public Entry<T> next() {
+            Map.Entry<Integer, T> val = parent.next();
+            if (val == null) return null;
+            return new IntWrapperEntry<T>(val);
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+    }
+
+    public static <T> ObjectIterator<Entry<T>> intMapItrFake(Map<Integer, T> in) {
+        return new WrapperIntEntryObjectIterator<T>(in.entrySet().iterator());
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterator<T> in) {
+        return new WrapperObjectIterator<T>(in);
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterable<T> in) {
+        return new WrapperObjectIterator<T>(in.iterator());
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..bb6c592fd34423fdd910feae83a058d288da537a
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java
@@ -0,0 +1,93 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+import org.apache.commons.lang3.NotImplementedException;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Int2ObjectConcurrentHashMap<V> implements Int2ObjectMap<V> {
+
+    Map<Integer, V> backing;
+
+    public Int2ObjectConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Integer, V>();
+    }
+
+    @Override
+    public V get(int key) {
+        return backing.get(key);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Integer, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        throw new NotImplementedException("MCMT - Not implemented");
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> int2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetIntWrap(backing);
+    }
+
+
+    @Override
+    public IntSet keySet() {
+        return FastUtilHackUtil.wrapIntSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(int key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(int key, V value) {
+        return backing.put(key, value);
+    }
+
+    @Override
+    public V put(Integer key, V value) {
+        return backing.put(key, value);
+    }
+
+    @Override
+    public V remove(int key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public void clear() { backing.clear(); }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0fab16860e1be817fd10dbec684f295f2e291dd
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java
@@ -0,0 +1,99 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.longs.Long2ByteMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2ByteConcurrentHashMap implements Long2ByteMap {
+
+    Map<Long, Byte> backing;
+    byte defaultReturn = 0;
+    byte nullKey = 0;
+
+    public Long2ByteConcurrentHashMap() {
+        backing = new ConcurrentHashMap<>();
+    }
+
+    public Long2ByteConcurrentHashMap(int initialCapacity, float loadFactor) {
+        backing = new ConcurrentHashMap<>(initialCapacity, loadFactor);
+    }
+
+    @Override
+    public byte get(long key) {
+        Byte out = backing.get(key);
+        return out == null ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(byte value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Byte> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(byte rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public byte defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2ByteEntrySet() {
+        return FastUtilHackUtil.entrySetLongByteWrap(backing);
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ByteCollection values() {
+        return FastUtilHackUtil.wrapBytes(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public byte put(long key, byte value) {
+        return put((Long) key, (Byte) value);
+    }
+
+    @Override
+    public Byte put(Long key, Byte value) {
+        Byte out = backing.put(key, value);
+        return out == null ? Byte.valueOf(defaultReturn) : out;
+    }
+
+    @Override
+    public byte remove(long key) {
+        Byte out = backing.remove(key);
+        return out == null ? defaultReturn : out;
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..261f06a88021a95b6a0500444665547aeb4ae2c1
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java
@@ -0,0 +1,74 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2IntConcurrentHashMap implements Long2IntMap {
+
+    public Map<Long, Integer> backing = new ConcurrentHashMap<Long, Integer>();
+    int defaultRV = 0;
+
+    @Override
+    public int get(long key) {
+        if (backing.containsKey(key)) {
+            return backing.get(key);
+        } else return defaultRV;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Integer> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(int rv) {
+        defaultRV = rv;
+    }
+
+    @Override
+    public int defaultReturnValue() {
+        return defaultRV;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2IntEntrySet() {
+        return null;
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public IntCollection values() {
+        return FastUtilHackUtil.wrapInts(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(int value) {
+        return backing.containsValue(value);
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc2342486318721d399c7c60a0a859befb4d1c9f
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java
@@ -0,0 +1,375 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.Hash;
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.longs.*;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+@SuppressWarnings("deprecation")
+public class Long2IntConcurrentNonLinkedOpenMap extends Long2IntLinkedOpenHashMap {
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = -2082212127278131631L;
+
+    public Map<Long, Integer> backing = new ConcurrentHashMap<Long, Integer>();
+
+    public Long2IntConcurrentNonLinkedOpenMap(final int expected, final float f) {
+
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
+     *
+     * @param expected the expected number of elements in the hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final int expected) {
+    }
+
+    /**
+     * Creates a new hash map with initial expected
+     * {@link Hash#DEFAULT_INITIAL_SIZE} entries and
+     * {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap() {
+    }
+
+    /**
+     * Creates a new hash map copying a given one.
+     *
+     * @param m a {@link Map} to be copied into the new hash map.
+     * @param f the load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Map<? extends Long, ? extends Integer> m, final float f) {
+        putAll(m);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * copying a given one.
+     *
+     * @param m a {@link Map} to be copied into the new hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Map<? extends Long, ? extends Integer> m) {
+        this(m, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new hash map copying a given type-specific one.
+     *
+     * @param m a type-specific map to be copied into the new hash map.
+     * @param f the load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Long2IntMap m, final float f) {
+        this(m.size(), f);
+        putAll(m);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * copying a given type-specific one.
+     *
+     * @param m a type-specific map to be copied into the new hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Long2IntMap m) {
+        this(m, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new hash map using the elements of two parallel arrays.
+     *
+     * @param k the array of keys of the new hash map.
+     * @param v the array of corresponding values in the new hash map.
+     * @param f the load factor.
+     * @throws IllegalArgumentException if {@code k} and {@code v} have different
+     *                                  lengths.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final long[] k, final int[] v, final float f) {
+        if (k.length != v.length)
+            throw new IllegalArgumentException(
+                    "The key array and the value array have different lengths (" + k.length + " and " + v.length + ")");
+        for (int i = 0; i < k.length; i++)
+            this.put(k[i], v[i]);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * using the elements of two parallel arrays.
+     *
+     * @param k the array of keys of the new hash map.
+     * @param v the array of corresponding values in the new hash map.
+     * @throws IllegalArgumentException if {@code k} and {@code v} have different
+     *                                  lengths.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final long[] k, final int[] v) {
+        this(k, v, DEFAULT_LOAD_FACTOR);
+    }
+
+    public void putAll(Map<? extends Long, ? extends Integer> m) {
+        backing.putAll(m);
+    }
+
+    public int put(final long k, final int v) {
+        Integer out = backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int addTo(final long k, final int incr) {
+        Integer out =  backing.put(k, this.get(k)+incr);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int remove(final long k) {
+        Integer out = backing.remove(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int removeFirstInt() {
+        Integer out = this.remove(backing.keySet().stream().findAny().get());
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int removeLastInt() {
+        Integer out = this.remove(backing.keySet().stream().findAny().get());
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int getAndMoveToFirst(final long k) {
+        Integer out = backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int getAndMoveToLast(final long k) {
+        Integer out = backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putAndMoveToFirst(final long k, final int v) {
+        Integer out =  backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putAndMoveToLast(final long k, final int v) {
+        Integer out =  backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int get(final long k) {
+        Integer out =  backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public boolean containsKey(final long k) {
+        return backing.containsKey(k);
+    }
+
+    public boolean containsValue(final int v) {
+        return backing.containsValue(v);
+    }
+
+    public int getOrDefault(final long k, final int defaultValue) {
+        Integer out =  backing.getOrDefault(k, defaultValue);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putIfAbsent(final long k, final int v) {
+        Integer out =  backing.putIfAbsent(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public boolean remove(final long k, final int v) {
+        return backing.remove(k, v);
+    }
+
+
+    public boolean replace(final long k, final int oldValue, final int v) {
+        return  backing.replace(k, oldValue, v);
+    }
+
+
+    public int replace(final long k, final int v) {
+        Integer out = backing.replace(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfAbsent(final long k, final java.util.function.LongToIntFunction mappingFunction) {
+        Integer out =  backing.computeIfAbsent(k, (l) -> mappingFunction.applyAsInt(l));
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfAbsentNullable(final long k,
+                                       final java.util.function.LongFunction<? extends Integer> mappingFunction) {
+        Integer out =  backing.computeIfAbsent(k, (l) -> mappingFunction.apply(l));
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfPresent(final long k,
+                                final java.util.function.BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        if (this.containsKey(k)) {
+            Integer out =  backing.put(k, remappingFunction.apply(k, backing.get(k)));
+            if (out == null) {
+                return defRetValue;
+            }
+            return out;
+        }
+        return defaultReturnValue();
+
+    }
+
+    @Override
+    public int compute(final long k,
+                       final java.util.function.BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        Integer out =  backing.compute(k, remappingFunction);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    @Override
+    public int merge(final long k, final int v,
+                     final java.util.function.BiFunction<? super Integer, ? super Integer, ? extends Integer> remappingFunction) {
+        Integer out =  backing.merge(k, v, remappingFunction);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public long firstLongKey() {
+        return backing.keySet().stream().findAny().get();
+    }
+
+    @Override
+    public long lastLongKey() {
+        return backing.keySet().stream().findAny().get();
+    }
+
+    @Override
+    public Long2IntSortedMap tailMap(long from) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Long2IntSortedMap headMap(long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Long2IntSortedMap subMap(long from, long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+
+    @Override
+    public FastSortedEntrySet long2IntEntrySet() {
+        //TODO implement
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongSortedSet keySet() {
+        return FastUtilHackUtil.wrapLongSortedSet(backing.keySet());
+    }
+
+
+    @Override
+    public IntCollection values() {
+        return FastUtilHackUtil.wrapInts(backing.values());
+    }
+
+    public boolean trim() {
+        return true;
+    }
+
+    public boolean trim(final int n) {
+        return true;
+    }
+
+
+    @Override
+    public Long2IntConcurrentNonLinkedOpenMap clone() {
+        return new Long2IntConcurrentNonLinkedOpenMap(backing);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..3205d30a03f99caf7dfa05237b2bc31182b2db20
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java
@@ -0,0 +1,97 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+public class Long2LongConcurrentHashMap implements Long2LongMap {
+
+    public Map<Long, Long> backing = new ConcurrentHashMap<Long, Long>();
+    long defaultRV = 0;
+
+    public Long2LongConcurrentHashMap(long defaultRV) {
+        this.defaultRV = defaultRV;
+    }
+
+    @Override
+    public long get(long key) {
+        if (backing.containsKey(key)) {
+            return backing.get(key);
+        } else return defaultRV;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public long put(final long key, final long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public Long put(final Long key, final Long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public long remove(final long key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Long> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(long rv) {
+        defaultRV = rv;
+    }
+
+    @Override
+    public long defaultReturnValue() {
+        return defaultRV;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2LongEntrySet() {
+        return FastUtilHackUtil.entrySetLongLongWrap(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public LongCollection values() {
+        return FastUtilHackUtil.wrapLongs(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(long value) {
+        return backing.containsValue(value);
+    }
+
+
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5ed71564d4c9a986f77cbc0397130aa38f97a91
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java
@@ -0,0 +1,93 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2ObjectConcurrentHashMap<V> implements Long2ObjectMap<V> {
+
+    Map<Long, V> backing;
+    V defaultReturn = null;
+
+    public Long2ObjectConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, V>();
+    }
+
+    @Override
+    public V get(long key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrap(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        return put((Long)key, value);
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        V out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public V remove(long key) {
+        V out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7d6be048ab3b8bd38231fce16eca0ac78e24690
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java
@@ -0,0 +1,233 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectFunction;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Function;
+
+public class Long2ObjectOpenConcurrentHashMap<V> extends Long2ObjectOpenHashMap<V> {
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = -121514116954680057L;
+
+    Map<Long, V> backing;
+    V defaultReturn = null;
+
+    public Long2ObjectOpenConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, V>();
+    }
+
+    @Override
+    public V get(long key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public V get(Object key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public FastEntrySet<V> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrapFast(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        return put((Long)key, value);
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        V out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public V remove(long key) {
+        V out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean trim() { return true; }
+
+    @Override
+    public boolean trim(final int n) { return true; }
+
+    @Override
+    public boolean replace(final long k, final V oldValue, final V v) {
+        return backing.replace(k, oldValue, v);
+    }
+
+    @Override
+    public V replace(final long k, final V v) {
+        return backing.replace(k, v);
+    }
+
+    @Override
+    public boolean replace(final Long k, final V oldValue, final V v) {
+        return backing.replace(k, oldValue, v);
+    }
+
+    @Override
+    public V replace(final Long k, final V v) {
+        return backing.replace(k, v);
+    }
+
+    @Override
+    public boolean remove(final long k, final Object v) {
+        return backing.remove(k, v);
+    }
+
+    @Override
+    public V putIfAbsent(final long k, final V v) {
+        return backing.putIfAbsent(k, v);
+    }
+
+    @Override
+    public V putIfAbsent(final Long k, final V v) {
+        return backing.putIfAbsent(k, v);
+    }
+
+    @Override
+    public V merge(final long k, final V v, final java.util.function.BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return backing.merge(k, v, remappingFunction);
+    }
+
+    @Override
+    public V merge(Long k, final V v, final java.util.function.BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return backing.merge(k, v, remappingFunction);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public V getOrDefault(final long k, final V defaultValue) {
+        return backing.getOrDefault(k, defaultValue);
+    }
+
+    @Override
+    public V getOrDefault(Object k, final V defaultValue) {
+        return backing.getOrDefault(k, defaultValue);
+    }
+
+    @Override
+    public V computeIfPresent(final long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.computeIfPresent(k, remappingFunction);
+    }
+
+    @Override
+    public V computeIfPresent(final Long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.computeIfPresent(k, remappingFunction);
+    }
+
+    @Override
+    public V computeIfAbsent(final long k, final java.util.function.LongFunction<? extends V> mappingFunction) {
+        return backing.computeIfAbsent(k, (llong) -> mappingFunction.apply(llong));
+    }
+
+    public V computeIfAbsent(final Long k, final java.util.function.LongFunction<? extends V> mappingFunction) {
+        return backing.computeIfAbsent(k, (llong) -> mappingFunction.apply(llong));
+    }
+
+    @Override
+    public V computeIfAbsentPartial(final long key, final Long2ObjectFunction<? extends V> mappingFunction) {
+        if (!mappingFunction.containsKey(key))
+            return defaultReturn;
+        return backing.computeIfAbsent(key, (llong) -> mappingFunction.apply(llong));
+    }
+
+    @Override
+    public V compute(final long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.compute(k, remappingFunction);
+    }
+
+    @Override
+    public V compute(final Long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.compute(k, remappingFunction);
+    }
+
+    @Override
+    public Long2ObjectOpenHashMap<V> clone() {
+        throw new IllegalArgumentException();
+    }
+
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, V>> entrySet() {
+        return new FastUtilHackUtil.ConvertingObjectSet<Map.Entry<Long, V>, Map.Entry<Long, V>>(backing.entrySet(), Function.identity(), Function.identity());
+    }
+
+    @Override
+    public V remove(Object key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public boolean remove(Object key, Object value) {
+        return backing.remove(key, value);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d65e9575389a170e8b8465b1221a6e319749eb1
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java
@@ -0,0 +1,190 @@
+package net.himeki.mcmtfabric.parallelised.fastutil.sync;
+
+import it.unimi.dsi.fastutil.longs.*;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+public class SyncLongLinkedOpenHashSet extends LongLinkedOpenHashSet {
+
+    private static final long serialVersionUID = -5532128240738069111L;
+
+    public SyncLongLinkedOpenHashSet() {
+        super();
+    }
+
+    public SyncLongLinkedOpenHashSet(final int initial) {
+        super(initial);
+    }
+
+    public SyncLongLinkedOpenHashSet(final int initial, final float dnc) {
+        this(initial);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongCollection c) {
+        this(c.size());
+        addAll(c);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongCollection c, final float f) {
+        this(c.size(), f);
+        addAll(c);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongIterator i, final float f) {
+        this(16, f);
+        while (i.hasNext())
+            add(i.nextLong());
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongIterator i) {
+        this(i, -1);
+    }
+
+    public SyncLongLinkedOpenHashSet(final Iterator<?> i, final float f) {
+        this(LongIterators.asLongIterator(i), f);
+    }
+
+    public SyncLongLinkedOpenHashSet(final Iterator<?> i) {
+        this(LongIterators.asLongIterator(i));
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final int offset, final int length, final float f) {
+        this(length < 0 ? 0 : length, f);
+        LongArrays.ensureOffsetLength(a, offset, length);
+        for (int i = 0; i < length; i++)
+            add(a[offset + i]);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final int offset, final int length) {
+        this(a, offset, length, DEFAULT_LOAD_FACTOR);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final float f) {
+        this(a, 0, a.length, f);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a) {
+        this(a, -1);
+    }
+
+    @Override
+    public synchronized boolean add(final long k) {
+        return super.add(k);
+    }
+
+    @Override
+    public synchronized boolean addAll(LongCollection c) {
+        return super.addAll(c);
+    }
+
+    @Override
+    public synchronized boolean addAll(Collection<? extends Long> c) {
+        return super.addAll(c);
+    }
+
+    @Override
+    public synchronized boolean addAndMoveToFirst(final long k) {
+        return super.addAndMoveToFirst(k);
+    }
+
+    @Override
+    public synchronized boolean addAndMoveToLast(final long k) {
+        return super.addAndMoveToFirst(k);
+    }
+
+    @Override
+    public synchronized void clear() {
+        super.clear();
+    }
+
+    @Override
+    public synchronized LongLinkedOpenHashSet clone() {
+        return new SyncLongLinkedOpenHashSet(this);
+    }
+
+    @Override
+    public synchronized LongComparator comparator() {
+        return super.comparator();
+    }
+
+    @Override
+    public synchronized boolean contains(final long k) {
+        return super.contains(k);
+    }
+
+    @Override
+    public synchronized long firstLong() {
+        return super.firstLong();
+    }
+
+    @Override
+    public synchronized int hashCode() {
+        return super.hashCode();
+    }
+
+    @Override
+    public synchronized LongSortedSet headSet(long to) {
+        return super.headSet(to);
+    }
+
+    @Override
+    public synchronized boolean isEmpty() {
+        return super.isEmpty();
+    }
+
+    @Override
+    public synchronized LongListIterator iterator() {
+        return super.iterator();
+    }
+
+    @Override
+    public synchronized LongListIterator iterator(long from) {
+        return super.iterator(from);
+    }
+
+    @Override
+    public synchronized long lastLong() {
+        return super.lastLong();
+    }
+
+    @Override
+    public synchronized boolean remove(final long k) {
+        return super.remove(k);
+    }
+
+    @Override
+    public synchronized long removeFirstLong() {
+        return super.removeFirstLong();
+    }
+
+    @Override
+    public synchronized long removeLastLong() {
+        return super.removeLastLong();
+    }
+
+    @Override
+    public synchronized int size() {
+        return super.size();
+    }
+
+    @Override
+    public synchronized LongSortedSet subSet(long from, long to) {
+        return super.subSet(from, to);
+    }
+
+    @Override
+    public synchronized LongSortedSet tailSet(long from) {
+        return super.tailSet(from);
+    }
+
+    @Override
+    public synchronized boolean trim() {
+        return super.trim();
+    }
+
+    @Override
+    public synchronized boolean trim(final int n) {
+        return super.trim(n);
+    }
+}
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 24c677e80af652952263253409c050641e72e3b5..c6f9fb3efb92de0879eab6389fabd531bb4cfcb2 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -1,7 +1,8 @@
 package net.minecraft.network.protocol.game;
 
-import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.function.BiConsumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -22,14 +23,16 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section, boolean noLightingUpdates) {
         this.sectionPos = sectionPos;
         this.suppressLightUpdates = noLightingUpdates;
-        int i = positions.size();
+        final List<Short> copy = new ArrayList<>(positions);
+        this.positions = new short[copy.size()];
+        this.states = new BlockState[copy.size()];
+        for (int i = 0; i < copy.size(); i++) {
+            this.positions[i] = copy.get(i);
+        }
 
-        this.positions = new short[i];
-        this.states = new BlockState[i];
-        int j = 0;
 
-        for (ShortIterator shortiterator = positions.iterator(); shortiterator.hasNext(); ++j) {
-            short short0 = (Short) shortiterator.next();
+        for (int j = 0;j < this.positions.length;j++) {
+            short short0 = this.positions[j];
 
             this.positions[j] = short0;
             this.states[j] = (section != null) ? section.getBlockState(SectionPos.sectionRelativeX(short0), SectionPos.sectionRelativeY(short0), SectionPos.sectionRelativeZ(short0)) : net.minecraft.world.level.block.Blocks.AIR.defaultBlockState(); // CraftBukkit - SPIGOT-6076, Mojang bug when empty chunk section notified
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index cea4447aad2d64db56a76e4ba180dc7326d2e13b..df1e5723eb30195705cc64de3214a4326856ff34 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1,10 +1,10 @@
 package net.minecraft.server;
 
+import cc.keyimc.keyi.server.PublicConstants;
+import cc.keyimc.keyi.server.ServerEntityTickHook;
+import cc.keyimc.keyi.server.ServerLevelTickHook;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
-import co.aikar.timings.Timings;
-import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
-import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -85,7 +85,6 @@ import net.minecraft.server.level.ServerChunkCache;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.level.ServerPlayerGameMode;
-import net.minecraft.server.level.TicketType;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.level.progress.ChunkProgressListenerFactory;
 import net.minecraft.server.network.ServerConnectionListener;
@@ -109,17 +108,14 @@ import net.minecraft.util.NativeModuleLister;
 import net.minecraft.util.ProgressListener;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.SignatureValidator;
-import net.minecraft.util.Unit;
 import net.minecraft.util.datafix.DataFixers;
 import net.minecraft.util.profiling.EmptyProfileResults;
 import net.minecraft.util.profiling.ProfileResults;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.profiling.ResultField;
-import net.minecraft.util.profiling.SingleTickProfiler;
 import net.minecraft.util.profiling.jfr.JvmProfiler;
 import net.minecraft.util.profiling.jfr.callback.ProfiledDuration;
 import net.minecraft.util.profiling.metrics.profiling.ActiveMetricsRecorder;
-import net.minecraft.util.profiling.metrics.profiling.InactiveMetricsRecorder;
 import net.minecraft.util.profiling.metrics.profiling.MetricsRecorder;
 import net.minecraft.util.profiling.metrics.profiling.ServerMetricsSamplersProvider;
 import net.minecraft.util.profiling.metrics.storage.MetricsPersister;
@@ -183,12 +179,6 @@ import net.minecraft.world.level.levelgen.PatrolSpawner;
 import net.minecraft.world.level.levelgen.PhantomSpawner;
 import net.minecraft.world.level.levelgen.WorldDimensions;
 import net.minecraft.world.level.levelgen.presets.WorldPresets;
-import org.bukkit.Bukkit;
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.Main;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
-import org.bukkit.craftbukkit.util.LazyPlayerSet;
-import org.bukkit.event.player.AsyncPlayerChatPreviewEvent;
 import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
@@ -233,7 +223,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private String localIp;
     private int port;
     private final LayeredRegistryAccess<RegistryLayer> registries;
-    private Map<ResourceKey<Level>, ServerLevel> levels;
+    public Map<ResourceKey<Level>, ServerLevel> levels;
     private PlayerList playerList;
     private volatile boolean running;
     private volatile boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
@@ -924,10 +914,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         if (!hasLoggedStop && isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper
         // Paper start - kill main thread, and kill it hard
+        try {
+            PublicConstants.WORKER_MANAGER.shutdownAll(); //KeYi-MT
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
         shutdownThread = Thread.currentThread();
         org.spigotmc.WatchdogThread.doStop(); // Paper
         if (!isSameThread()) {
-            MinecraftServer.LOGGER.info("Stopping main thread (Ignore any thread death message you see! - DO NOT REPORT THREAD DEATH TO PURPUR)"); // Purpur
+            MinecraftServer.LOGGER.info("Stopping main thread (Ignore any thread death message you see! - DO NOT REPORT THREAD DEATH TO PAPER or PURPUR! REPORT TO HEARSE INSTEAD!)"); // Purpur // Hearse
             while (this.getRunningThread().isAlive()) {
                 this.getRunningThread().stop();
                 try {
@@ -1141,6 +1136,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             Arrays.fill( recentTps, 20 );
             long start = System.nanoTime(), curTime, tickSection = start; // Paper - Further improve server tick loop
             lastTick = start - TICK_TIME; // Paper
+            ServerLevelTickHook.init(); //Hearse
             while (this.running) {
                 // Paper start - rewrite chunk system
                 // guarantee that nothing can stop the server from halting if it can at least still tick
@@ -1419,9 +1415,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         //isOversleep = false;MinecraftTimings.serverOversleep.stopTiming(); // Purpur
         // Paper end
         new com.destroystokyo.paper.event.server.ServerTickStartEvent(this.tickCount+1).callEvent(); // Paper
-
         ++this.tickCount;
         this.tickChildren(shouldKeepTicking);
+
         if (i - this.lastServerStatus >= 5000000000L) {
             this.lastServerStatus = i;
             this.status.setPlayers(new ServerStatus.Players(this.getMaxPlayers(), this.getPlayerCount()));
@@ -1538,11 +1534,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         this.isIteratingOverLevels = true; // Paper
         net.minecraft.network.FriendlyByteBuf.hasItemSerializeEvent = org.purpurmc.purpur.event.packet.NetworkItemSerializeEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
-        Iterator iterator = this.getAllLevels().iterator(); // Paper - move down
-        while (iterator.hasNext()) {
-            ServerLevel worldserver = (ServerLevel) iterator.next();
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            worldserver.hasEntityMoveEvent =  io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+        // Paper - move down
+        for (ServerLevel worldserver : this.getAllLevels()) {
+            worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+            worldserver.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
             worldserver.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
             net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
 
@@ -1558,35 +1553,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // CraftBukkit end */
 
             //this.profiler.push("tick"); // Purpur
-
-            try {
-                //worldserver.timings.doTick.startTiming(); // Spigot // Purpur
-                worldserver.tick(shouldKeepTicking);
-                // Paper start
-                for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
-                    regionManager.recalculateRegions();
-                }
-                // Paper end
-                //worldserver.timings.doTick.stopTiming(); // Spigot // Purpur
-            } catch (Throwable throwable) {
-                // Spigot Start
-                CrashReport crashreport;
-                try {
-                    crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
-                } catch (Throwable t) {
-                    if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
-                    throw new RuntimeException("Error generating crash report", t);
-                }
-                // Spigot End
-
-                worldserver.fillReportDetails(crashreport);
-                throw new ReportedException(crashreport);
-            }
-
-            //this.profiler.pop(); // Purpur
-            //this.profiler.pop(); // Purpur
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+            ServerLevelTickHook.callWorldTick(worldserver,shouldKeepTicking);
         }
+        ServerEntityTickHook.awaitEntityTasks();
+        ServerLevelTickHook.awaitWorldTicKTasks();
         this.isIteratingOverLevels = false; // Paper
 
         //this.profiler.popPush("connection"); // Purpur
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index c13b82b7996297108858e383bc9c2da314f98203..6fdf9b1d6b9b592ffd3b909135420070ef1f64c1 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -1,20 +1,17 @@
 package net.minecraft.server.dedicated;
 
-import com.google.common.collect.Lists;
+import cc.keyimc.keyi.server.ServerEntityTickHook;
+import cc.keyimc.keyi.server.ServerLevelTickHook;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
-import java.io.BufferedReader;
+
 import java.io.BufferedWriter;
 import java.io.IOException;
-import java.io.InputStreamReader;
 import java.net.InetAddress;
 import java.net.Proxy;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.Collections;
-import java.util.List;
 import java.util.Locale;
 import java.util.Optional;
 import java.util.function.BooleanSupplier;
@@ -58,7 +55,6 @@ import org.apache.logging.log4j.Level;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.io.IoBuilder;
 import org.bukkit.command.CommandSender;
-import co.aikar.timings.MinecraftTimings; // Paper
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
@@ -242,6 +238,10 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             logger.log(Level.ERROR, "Failed to load KeYi config!", e);
         }
         // KeYi end
+        ServerEntityTickHook.init();
+        //KeYi-MT start - init workers
+
+        //KeYiMt end
 
         cc.keyimc.keyi.KeyiCommand.init(); // KeYi - init command
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index bc46479fd0622a90fd98ac88f92b2840a22a2d04..ebb1c69f905ef3c948a65c9f095244b7e663b3a9 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -2,19 +2,8 @@ package net.minecraft.server.level;
 
 import com.mojang.datafixers.util.Either;
 import com.mojang.datafixers.util.Pair;
-import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.List;
-import java.util.Optional;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicReferenceArray;
-import java.util.function.IntConsumer;
-import java.util.function.IntSupplier;
-import javax.annotation.Nullable;
-import net.minecraft.Util;
+import net.himeki.mcmtfabric.parallelised.fastutil.ConcurrentShortHashSet;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.protocol.Packet;
@@ -29,15 +18,15 @@ import net.minecraft.world.level.LevelHeightAccessor;
 import net.minecraft.world.level.LightLayer;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
-import net.minecraft.world.level.chunk.ChunkAccess;
-import net.minecraft.world.level.chunk.ChunkStatus;
-import net.minecraft.world.level.chunk.ImposterProtoChunk;
-import net.minecraft.world.level.chunk.LevelChunk;
-import net.minecraft.world.level.chunk.LevelChunkSection;
-import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.level.chunk.*;
 import net.minecraft.world.level.lighting.LevelLightEngine;
-// CraftBukkit start
-import net.minecraft.server.MinecraftServer;
+
+import javax.annotation.Nullable;
+import java.util.BitSet;
+import java.util.List;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.IntConsumer;
+import java.util.function.IntSupplier;
 // CraftBukkit end
 
 public class ChunkHolder {
@@ -233,7 +222,7 @@ public class ChunkHolder {
             if (i < 0 || i >= this.changedBlocksPerSection.length) return; // CraftBukkit - SPIGOT-6086, SPIGOT-6296
             if (this.changedBlocksPerSection[i] == null) {
                 this.hasChangedSections = true; this.addToBroadcastMap(); // Paper - optimise chunk tick iteration
-                this.changedBlocksPerSection[i] = new ShortOpenHashSet();
+                this.changedBlocksPerSection[i] = new ConcurrentShortHashSet();
             }
 
             this.changedBlocksPerSection[i].add(SectionPos.sectionRelativePos(pos));
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 75965afd7b4bed23a5ecf618c7f91ff5e7ffd92f..981a3f7549cc3fe35f02b3cfae9158b8e56204c6 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1,57 +1,21 @@
 package net.minecraft.server.level;
 
-import co.aikar.timings.Timing; // Paper
-import com.google.common.collect.ImmutableList;
+import cc.keyimc.keyi.Hearse;
+import cc.keyimc.keyi.HearseConfig;
+import cc.keyimc.keyi.concurrent.WorkerThreadPoolExecutor;
+import cc.keyimc.keyi.concurrent.threadfactory.DefaultWorkerFactory;
+import cc.keyimc.keyi.config.KGlobalConfig;
+import com.google.common.collect.*;
 import com.google.common.collect.ImmutableList.Builder;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.ComparisonChain; // Paper
-import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import com.google.gson.JsonElement;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.JsonOps;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2LongMap;
-import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
-import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import java.io.IOException;
-import java.io.Writer;
-import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.CompletionStage;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BooleanSupplier;
-import java.util.function.Consumer;
-import java.util.function.IntFunction;
-import java.util.function.IntSupplier;
-import java.util.function.Supplier;
-import java.util.stream.Collectors;
-import javax.annotation.Nullable;
+import io.papermc.paper.util.MCUtil;
+import it.unimi.dsi.fastutil.longs.*;
+import it.unimi.dsi.fastutil.objects.*;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -63,36 +27,19 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
-import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
-import io.papermc.paper.util.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.server.network.ServerPlayerConnection;
-import net.minecraft.util.CsvOutput;
 import net.minecraft.util.Mth;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.thread.BlockableEventLoop;
-import net.minecraft.util.thread.ProcessorHandle;
-import net.minecraft.util.thread.ProcessorMailbox;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.Mob;
 import net.minecraft.world.entity.ai.village.poi.PoiManager;
 import net.minecraft.world.entity.boss.EnderDragonPart;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.chunk.ChunkAccess;
-import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.chunk.ChunkGeneratorStructureState;
-import net.minecraft.world.level.chunk.ChunkStatus;
-import net.minecraft.world.level.chunk.ImposterProtoChunk;
-import net.minecraft.world.level.chunk.LevelChunk;
-import net.minecraft.world.level.chunk.LightChunkGetter;
-import net.minecraft.world.level.chunk.ProtoChunk;
-import net.minecraft.world.level.chunk.UpgradeData;
+import net.minecraft.world.level.chunk.*;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
 import net.minecraft.world.level.chunk.storage.ChunkStorage;
 import net.minecraft.world.level.entity.ChunkStatusUpdateListener;
@@ -101,19 +48,22 @@ import net.minecraft.world.level.levelgen.NoiseBasedChunkGenerator;
 import net.minecraft.world.level.levelgen.NoiseGeneratorSettings;
 import net.minecraft.world.level.levelgen.RandomState;
 import net.minecraft.world.level.levelgen.blending.BlendingData;
-import net.minecraft.world.level.levelgen.structure.StructureStart;
 import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemplateManager;
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
-import net.minecraft.world.phys.Vec3;
-import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.commons.lang3.mutable.MutableObject;
-import org.slf4j.Logger;
 import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
-import org.bukkit.entity.Player;
-// CraftBukkit end
+import org.slf4j.Logger;
 
-import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.io.Writer;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.*;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -147,13 +97,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final StructureTemplateManager structureTemplateManager; // Paper - rewrite chunk system
     private final String storageName;
     private final PlayerMap playerMap;
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
+    public final Map<Integer,ChunkMap.TrackedEntity> entityMap;
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
     int viewDistance;
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
-    public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
+    public final ReferenceSet<ChunkHolder> needsChangeBroadcasting = ReferenceSets.synchronize(new ReferenceOpenHashSet<>());
 
     // Paper - rewrite chunk system
     // Paper start - optimise checkDespawn
@@ -295,9 +245,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
-        this.chunkTypeCache = new Long2ByteOpenHashMap();
-        this.chunkSaveCooldowns = new Long2LongOpenHashMap();
+        this.entityMap = Maps.newConcurrentMap();
+        this.chunkTypeCache = Long2ByteMaps.synchronize(new Long2ByteOpenHashMap());
+        this.chunkSaveCooldowns = Long2LongMaps.synchronize(new Long2LongOpenHashMap());
         this.unloadQueue = Queues.newConcurrentLinkedQueue();
         this.structureTemplateManager = structureTemplateManager;
         Path path = session.getDimensionPath(world.dimension());
@@ -1183,8 +1133,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
         // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
         if (!entity.valid || entity.level != this.level || this.entityMap.containsKey(entity.getId())) {
-            LOGGER.error("Illegal ChunkMap::addEntity for world " + this.level.getWorld().getName()
-                + ": " + entity  + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""), new Throwable());
+            LOGGER.error("Illegal ChunkMap::addEntity for world " + this.level.getWorld().getName() + ": " + entity  + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""));
             return;
         }
         if (entity instanceof ServerPlayer && ((ServerPlayer) entity).supressTrackerForLogin) return; // Delay adding to tracker until after list packets
@@ -1209,11 +1158,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         ServerPlayer entityplayer = (ServerPlayer) entity;
 
                         this.updatePlayerStatus(entityplayer, true);
-                        ObjectIterator objectiterator = this.entityMap.values().iterator();
-
-                        while (objectiterator.hasNext()) {
-                            ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
 
+                        for (TrackedEntity playerchunkmap_entitytracker1 : this.entityMap.values()) {
                             if (playerchunkmap_entitytracker1.entity != entityplayer) {
                                 playerchunkmap_entitytracker1.updatePlayer(entityplayer);
                             }
@@ -1231,11 +1177,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             ServerPlayer entityplayer = (ServerPlayer) entity;
 
             this.updatePlayerStatus(entityplayer, false);
-            ObjectIterator objectiterator = this.entityMap.values().iterator();
-
-            while (objectiterator.hasNext()) {
-                ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
 
+            for (TrackedEntity playerchunkmap_entitytracker : this.entityMap.values()) {
                 playerchunkmap_entitytracker.removePlayer(entityplayer);
             }
         }
@@ -1248,78 +1191,90 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         entity.tracker = null; // Paper - We're no longer tracked
     }
 
+    private final Executor asyncTrackWorker = new WorkerThreadPoolExecutor(
+            0,
+            2,
+            5L,
+            TimeUnit.SECONDS,
+            new LinkedBlockingQueue<>(),
+            new DefaultWorkerFactory("tracker-async"));
+    private static WorkerThreadPoolExecutor concurrentTrackWorker = null;
+    private final AtomicInteger totalRunning = new AtomicInteger(0);
+    private static final AtomicBoolean isInited = new AtomicBoolean(false);
+    private static final AtomicBoolean enabled = new AtomicBoolean();
+
+    public static void tryInitIfNotInited(){
+        if (!isInited.get()){
+            enabled.set(KGlobalConfig.getInstance().multiThreadTracker);
+            if (enabled.get()){
+                final int threadCount = KGlobalConfig.getInstance().multiThreadTrackerThreadCount;
+                concurrentTrackWorker = new WorkerThreadPoolExecutor(
+                        threadCount,
+                        threadCount,
+                        5L,
+                        TimeUnit.SECONDS,
+                        new LinkedBlockingQueue<>(),
+                        new DefaultWorkerFactory("tracker-concurrent"));
+                Hearse.getWorkerManager().addWorker("tracker",concurrentTrackWorker);
+            }
+            isInited.set(true);
+        }
+    }
+
     // Paper start - optimised tracker
     private final void processTrackQueue() {
-        //this.level.timings.tracker1.startTiming(); // Purpur
-        try {
+        tryInitIfNotInited();
+
+        if (!enabled.get()){
             for (TrackedEntity tracker : this.entityMap.values()) {
-                // update tracker entry
                 tracker.updatePlayers(tracker.entity.getPlayersInTrackRange());
             }
-        } finally {
-            //this.level.timings.tracker1.stopTiming(); // Purpur
-        }
-
 
-        //this.level.timings.tracker2.startTiming(); // Purpur
-        try {
             for (TrackedEntity tracker : this.entityMap.values()) {
                 tracker.serverEntity.sendChanges();
             }
-        } finally {
-            //this.level.timings.tracker2.stopTiming(); // Purpur
+            return;
         }
-    }
-    // Paper end - optimised tracker
 
-    protected void tick() {
-        // Paper start - optimized tracker
-        if (true) {
-            this.processTrackQueue();
+        if(this.totalRunning.get() > 0){
             return;
         }
-        // Paper end - optimized tracker
-        List<ServerPlayer> list = Lists.newArrayList();
-        List<ServerPlayer> list1 = this.level.players();
-        ObjectIterator objectiterator = this.entityMap.values().iterator();
-        //level.timings.tracker1.startTiming(); // Paper // Purpur
-
-        ChunkMap.TrackedEntity playerchunkmap_entitytracker;
-
-        while (objectiterator.hasNext()) {
-            playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
-            SectionPos sectionposition = playerchunkmap_entitytracker.lastSectionPos;
-            SectionPos sectionposition1 = SectionPos.of((EntityAccess) playerchunkmap_entitytracker.entity);
-            boolean flag = !Objects.equals(sectionposition, sectionposition1);
 
-            if (flag) {
-                playerchunkmap_entitytracker.updatePlayers(list1);
-                Entity entity = playerchunkmap_entitytracker.entity;
-
-                if (entity instanceof ServerPlayer) {
-                    list.add((ServerPlayer) entity);
-                }
-
-                playerchunkmap_entitytracker.lastSectionPos = sectionposition1;
+        this.totalRunning.set(2);
+
+        this.asyncTrackWorker.execute(()->{
+            //this.level.timings.tracker1.startTiming(); // Purpur
+            try {
+                CompletableFuture.allOf(this.entityMap.values()
+                        .stream()
+                        .map(tracker -> CompletableFuture.runAsync(()->{
+                            tracker.updatePlayers(tracker.entity.getPlayersInTrackRange());
+                        },concurrentTrackWorker))
+                        .toArray(CompletableFuture[]::new)).join();
+            } finally {
+                //this.level.timings.tracker1.stopTiming(); // Purpur
+                this.totalRunning.getAndDecrement();
             }
+        });
 
-            if (flag || this.distanceManager.inEntityTickingRange(sectionposition1.chunk().toLong())) {
-                playerchunkmap_entitytracker.serverEntity.sendChanges();
-            }
-        }
-        //level.timings.tracker1.stopTiming(); // Paper // Purpur
-
-        if (!list.isEmpty()) {
-            objectiterator = this.entityMap.values().iterator();
-
-            //level.timings.tracker2.startTiming(); // Paper // Purpur
-            while (objectiterator.hasNext()) {
-                playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
-                playerchunkmap_entitytracker.updatePlayers(list);
+        this.asyncTrackWorker.execute(()->{
+            //this.level.timings.tracker2.startTiming(); // Purpur
+            try {
+                for (TrackedEntity tracker : this.entityMap.values()) {
+                    tracker.serverEntity.sendChanges();
+                }
+            } finally {
+                //this.level.timings.tracker2.stopTiming(); // Purpur
+                this.totalRunning.getAndDecrement();
             }
-            //level.timings.tracker2.stopTiming(); // Paper // Purpur
-        }
+        });
+    }
+    // Paper end - optimised tracker
 
+    protected void tick() {
+        // Paper start - optimized tracker
+        this.processTrackQueue();
+        // Paper end - optimized tracker
     }
 
     public void broadcast(Entity entity, Packet<?> packet) {
@@ -1500,7 +1455,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         final Entity entity;
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new ReferenceOpenHashSet<>(); // Paper - optimise map impl
+        public final Set<ServerPlayerConnection> seenBy = Sets.newConcurrentHashSet(); // Paper - optimise map impl //Hearse - multithread tracker
 
         public TrackedEntity(Entity entity, int i, int j, boolean flag) {
             this.serverEntity = new ServerEntity(ChunkMap.this.level, entity, j, flag, this::broadcast, this.seenBy); // CraftBukkit
@@ -1518,12 +1473,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
             if (newTrackerCandidates != null) {
                 Object[] rawData = newTrackerCandidates.getBackingSet();
-                for (int i = 0, len = rawData.length; i < len; ++i) {
-                    Object raw = rawData[i];
+                for (Object raw : rawData) {
                     if (!(raw instanceof ServerPlayer)) {
                         continue;
                     }
-                    ServerPlayer player = (ServerPlayer)raw;
+                    ServerPlayer player = (ServerPlayer) raw;
                     this.updatePlayer(player);
                 }
             }
@@ -1554,14 +1508,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void broadcast(Packet<?> packet) {
-            Iterator iterator = this.seenBy.iterator();
-
-            while (iterator.hasNext()) {
-                ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
-
+            for (ServerPlayerConnection serverplayerconnection : this.seenBy) {
                 serverplayerconnection.send(packet);
             }
-
         }
 
         public void broadcastAndSend(Packet<?> packet) {
@@ -1573,14 +1522,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void broadcastRemoved() {
-            Iterator iterator = this.seenBy.iterator();
-
-            while (iterator.hasNext()) {
-                ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
-
+            for (ServerPlayerConnection serverplayerconnection : this.seenBy) {
                 this.serverEntity.removePairing(serverplayerconnection.getPlayer());
             }
-
         }
 
         public void removePlayer(ServerPlayer player) {
@@ -1588,7 +1532,6 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             if (this.seenBy.remove(player.connection)) {
                 this.serverEntity.removePairing(player);
             }
-
         }
 
         public void updatePlayer(ServerPlayer player) {
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 52cba8f68d274cce106304aef1249a95474d3238..a9ba8adc5f290f6e2820632bdae8e50165595706 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -1,42 +1,20 @@
 package net.minecraft.server.level;
 
-import com.google.common.annotations.VisibleForTesting;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
-import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
-import it.unimi.dsi.fastutil.longs.Long2ByteMap;
-import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2IntMap;
-import it.unimi.dsi.fastutil.longs.Long2IntMaps;
-import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectSet;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.Iterator;
-import java.util.Objects;
-import java.util.Set;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import javax.annotation.Nullable;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.SortedArraySet;
-import net.minecraft.util.thread.ProcessorHandle;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.ChunkStatus;
-import net.minecraft.world.level.chunk.LevelChunk;
 import org.slf4j.Logger;
+import javax.annotation.Nullable;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.concurrent.Executor;
 
 public abstract class DistanceManager {
 
@@ -52,7 +30,7 @@ public abstract class DistanceManager {
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
     private static final int ENTITY_TICKING_LEVEL_THRESHOLD = 32;
     private static final int BLOCK_TICKING_LEVEL_THRESHOLD = 33;
-    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
+    final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap());
     // Paper - rewrite chunk system
     public static final int MOB_SPAWN_RANGE = 8; // private final DistanceManager.FixedPlayerDistanceChunkTracker naturalSpawnChunkCounter = new DistanceManager.FixedPlayerDistanceChunkTracker(8); // Paper - no longer used
     //private final TickingTracker tickingTicketsTracker = new TickingTracker(); // Paper - no longer used
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 0ae45cf5a084fd412305e8b2f5dabe608b4eb1c1..4225863058114c527a3a420bb03e3f0de23254f5 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -1,46 +1,24 @@
 package net.minecraft.server.level;
 
+import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
-import java.io.File;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.Executor;
-import java.util.function.BooleanSupplier;
-import java.util.function.Consumer;
-import java.util.function.Supplier;
-import javax.annotation.Nullable;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.server.level.progress.ChunkProgressListener;
 import net.minecraft.util.VisibleForDebug;
-import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.util.thread.BlockableEventLoop;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.ai.village.poi.PoiManager;
-import net.minecraft.world.level.BlockGetter;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.LightLayer;
-import net.minecraft.world.level.LocalMobCapCalculator;
-import net.minecraft.world.level.NaturalSpawner;
-import net.minecraft.world.level.chunk.ChunkAccess;
-import net.minecraft.world.level.chunk.ChunkGenerator;
-import net.minecraft.world.level.chunk.ChunkGeneratorStructureState;
-import net.minecraft.world.level.chunk.ChunkSource;
-import net.minecraft.world.level.chunk.ChunkStatus;
-import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.*;
+import net.minecraft.world.level.chunk.*;
 import net.minecraft.world.level.chunk.storage.ChunkScanAccess;
 import net.minecraft.world.level.entity.ChunkStatusUpdateListener;
 import net.minecraft.world.level.levelgen.RandomState;
@@ -48,7 +26,16 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemp
 import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelStorageSource;
-import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+
+import javax.annotation.Nullable;
+import java.io.File;
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -72,8 +59,7 @@ public class ServerChunkCache extends ChunkSource {
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
     // Paper start
-    final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
-    final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<LevelChunk> loadedChunkMap = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>(8192, 0.5f);
+    private final Long2ObjectMap<LevelChunk> loadedChunkMap = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>(8192, 0.5f));
 
     private final LevelChunk[] lastLoadedChunks = new LevelChunk[4 * 4];
     
@@ -85,12 +71,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void addLoadedChunk(LevelChunk chunk) {
-        this.loadedChunkMapSeqLock.acquireWrite();
-        try {
-            this.loadedChunkMap.put(chunk.coordinateKey, chunk);
-        } finally {
-            this.loadedChunkMapSeqLock.releaseWrite();
-        }
+        this.loadedChunkMap.put(chunk.coordinateKey, chunk);
 
         // rewrite cache if we have to
         // we do this since we also cache null chunks
@@ -100,13 +81,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void removeLoadedChunk(LevelChunk chunk) {
-        this.loadedChunkMapSeqLock.acquireWrite();
-        try {
-            this.loadedChunkMap.remove(chunk.coordinateKey);
-        } finally {
-            this.loadedChunkMapSeqLock.releaseWrite();
-        }
-
+        this.loadedChunkMap.remove(chunk.coordinateKey);
         // rewrite cache if we have to
         // we do this since we also cache null chunks
         int cacheKey = getChunkCacheKey(chunk.locX, chunk.locZ);
@@ -375,22 +350,7 @@ public class ServerChunkCache extends ChunkSource {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
-        LevelChunk ret = null;
-        long readlock;
-        do {
-            readlock = this.loadedChunkMapSeqLock.acquireRead();
-            try {
-                ret = this.loadedChunkMap.get(k);
-            } catch (Throwable thr) {
-                if (thr instanceof ThreadDeath) {
-                    throw (ThreadDeath)thr;
-                }
-                // re-try, this means a CME occurred...
-                continue;
-            }
-        } while (!this.loadedChunkMapSeqLock.tryReleaseRead(readlock));
-
-        return ret;
+        return this.loadedChunkMap.get(k);
     }
     // Paper end
     // Paper start - async chunk io
@@ -416,23 +376,22 @@ public class ServerChunkCache extends ChunkSource {
     }
     // Paper end - async chunk io
 
+    private final Object schedulingMutex = new Object();
+
     @Nullable
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
-        final int x1 = x; final int z1 = z; // Paper - conflict on variable change
         if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
             }, this.mainThreadProcessor).join();
         } else {
-            // Paper start - optimise for loaded chunks
+            final int x1 = x; final int z1 = z; // Paper - conflict on variable change
+            //ProfilerFiller gameprofilerfiller = this.level.getProfiler(); // Purpur
             LevelChunk ifLoaded = this.getChunkAtIfLoadedMainThread(x, z);
             if (ifLoaded != null) {
                 return ifLoaded;
             }
-            // Paper end
-            //ProfilerFiller gameprofilerfiller = this.level.getProfiler(); // Purpur
-
             //gameprofilerfiller.incrementCounter("getChunk"); // Purpur
             long k = ChunkPos.asLong(x, z);
 
@@ -451,7 +410,7 @@ public class ServerChunkCache extends ChunkSource {
                 // Paper end
                 com.destroystokyo.paper.io.SyncLoadFinder.logSyncLoad(this.level, x1, z1); // Paper - sync load info
                 //this.level.timings.syncChunkLoad.startTiming(); // Paper // Purpur
-            chunkproviderserver_b.managedBlock(completablefuture::isDone);
+                chunkproviderserver_b.managedBlock(completablefuture::isDone);
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.popChunkWait(); // Paper - async chunk debug  // Paper - rewrite chunk system
                 //this.level.timings.syncChunkLoad.stopTiming(); // Paper // Purpur
             } // Paper
@@ -479,6 +438,7 @@ public class ServerChunkCache extends ChunkSource {
         }
     }
 
+
     private void clearCache() {
         Arrays.fill(this.lastChunkPos, ChunkPos.INVALID_CHUNK_POS);
         Arrays.fill(this.lastChunkStatus, (Object) null);
@@ -510,6 +470,7 @@ public class ServerChunkCache extends ChunkSource {
         // Paper start - add isUrgent - old sig left in place for dirty nms plugins
         return getChunkFutureMainThread(chunkX, chunkZ, leastStatus, create, false);
     }
+
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create, boolean isUrgent) {
         // Paper start - rewrite chunk system
         io.papermc.paper.util.TickThread.ensureTickThread(this.level, chunkX, chunkZ, "Scheduling chunk load off-main");
@@ -535,9 +496,9 @@ public class ServerChunkCache extends ChunkSource {
             };
 
             this.level.chunkTaskScheduler.scheduleChunkLoad(
-                chunkX, chunkZ, leastStatus, true,
-                isUrgent ? ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.BLOCKING : ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority.NORMAL,
-                complete
+                    chunkX, chunkZ, leastStatus, true,
+                    isUrgent ? PrioritisedExecutor.Priority.BLOCKING : PrioritisedExecutor.Priority.NORMAL,
+                    complete
             );
 
             return ret;
@@ -803,7 +764,7 @@ public class ServerChunkCache extends ChunkSource {
             //gameprofilerfiller.popPush("broadcast"); // Purpur
             //this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing // Purpur
             if (!this.chunkMap.needsChangeBroadcasting.isEmpty()) {
-                ReferenceOpenHashSet<ChunkHolder> copy = this.chunkMap.needsChangeBroadcasting.clone();
+                List<ChunkHolder> copy = new ArrayList<>(this.chunkMap.needsChangeBroadcasting);
                 this.chunkMap.needsChangeBroadcasting.clear();
                 for (ChunkHolder holder : copy) {
                     holder.broadcastChanges(holder.getFullChunkNowUnchecked()); // LevelChunks are NEVER unloaded
@@ -848,12 +809,10 @@ public class ServerChunkCache extends ChunkSource {
             if (chunkMap.playerMobDistanceMap != null && _pufferfish_spawnCountsReady.getAndSet(false)) {
                 net.minecraft.server.MinecraftServer.getServer().mobSpawnExecutor.submit(() -> {
                     int mapped = distanceManager.getNaturalSpawnChunkCount();
-                    io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> objectiterator =
-                            level.entityTickList.entities.iterator(io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS);
+                    Iterator<Entity> objectiterator = level.entityTickList.entities.iterator();
                     gg.pufferfish.pufferfish.util.IterableWrapper<Entity> wrappedIterator =
                             new gg.pufferfish.pufferfish.util.IterableWrapper<>(objectiterator);
                     lastSpawnState = NaturalSpawner.createState(mapped, wrappedIterator, this::getFullChunk, null, true);
-                    objectiterator.finishedIterating();
                     _pufferfish_spawnCountsReady.set(true);
                 });
             }
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 0f9a3a6c05fee59c29764f0c0d7a6cb8a2a861b1..ac00733448c9daebd9aa9626f3750ba0cb0e4031 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -3,14 +3,12 @@ package net.minecraft.server.level;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Set;
+
+import java.util.*;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.objects.ObjectArraySet;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
 import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
@@ -373,7 +371,7 @@ public class ServerEntity {
         }
 
         if (this.entity instanceof LivingEntity) {
-            Set<AttributeInstance> set = ((LivingEntity) this.entity).getAttributes().getDirtyAttributes();
+            List<AttributeInstance> set = new ArrayList<>(((LivingEntity) this.entity).getAttributes().getDirtyAttributes());
 
             if (!set.isEmpty()) {
                 // CraftBukkit start - Send scaled max health
@@ -394,6 +392,5 @@ public class ServerEntity {
         if (this.entity instanceof ServerPlayer) {
             ((ServerPlayer) this.entity).connection.send(packet);
         }
-
     }
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index b396a329e753f42b3878736b6b14bafda02d3744..4ef5d0beb6661684839629b61b6f6dc28421d60b 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -1,69 +1,35 @@
 package net.minecraft.server.level;
 
+import co.aikar.timings.TimingHistory;
+import cc.keyimc.keyi.concurrent.thread.Worker;
+import cc.keyimc.keyi.server.ServerEntityTickHook;
 import com.google.common.annotations.VisibleForTesting;
-import co.aikar.timings.TimingHistory; // Paper
 import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.MCUtil;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.longs.LongSets;
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
-import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
-import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.io.Writer;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.Executor;
-import java.util.function.BooleanSupplier;
-import java.util.function.Function;
-import java.util.function.Predicate;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.Util;
-import net.minecraft.core.BlockPos;
-import net.minecraft.core.Direction;
-import net.minecraft.core.Holder;
-import net.minecraft.core.HolderSet;
-import net.minecraft.core.RegistryAccess;
-import net.minecraft.core.SectionPos;
+import net.minecraft.core.*;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.Component;
-import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
-import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
-import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
-import net.minecraft.network.protocol.game.ClientboundExplodePacket;
-import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
-import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
-import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
-import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundSoundPacket;
-import net.minecraft.network.protocol.game.DebugPackets;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.resources.ResourceKey;
-import io.papermc.paper.util.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.ServerScoreboard;
 import net.minecraft.server.level.progress.ChunkProgressListener;
@@ -71,21 +37,10 @@ import net.minecraft.server.players.SleepStatus;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.tags.TagKey;
-import net.minecraft.util.AbortableIterationConsumer;
-import net.minecraft.util.CsvOutput;
-import net.minecraft.util.Mth;
-import net.minecraft.util.ProgressListener;
-import net.minecraft.util.Unit;
-import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.util.*;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
-import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.entity.LightningBolt;
-import net.minecraft.world.entity.LivingEntity;
-import net.minecraft.world.entity.Mob;
-import net.minecraft.world.entity.MobCategory;
-import net.minecraft.world.entity.ReputationEventHandler;
+import net.minecraft.world.entity.*;
 import net.minecraft.world.entity.ai.navigation.PathNavigation;
 import net.minecraft.world.entity.ai.village.ReputationEventType;
 import net.minecraft.world.entity.ai.village.poi.PoiManager;
@@ -102,17 +57,7 @@ import net.minecraft.world.entity.raid.Raid;
 import net.minecraft.world.entity.raid.Raids;
 import net.minecraft.world.flag.FeatureFlagSet;
 import net.minecraft.world.item.crafting.RecipeManager;
-import net.minecraft.world.level.BlockEventData;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.CustomSpawner;
-import net.minecraft.world.level.Explosion;
-import net.minecraft.world.level.ExplosionDamageCalculator;
-import net.minecraft.world.level.ForcedChunksSavedData;
-import net.minecraft.world.level.GameRules;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.NaturalSpawner;
-import net.minecraft.world.level.StructureManager;
-import net.minecraft.world.level.WorldGenLevel;
+import net.minecraft.world.level.*;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.biome.BiomeSource;
 import net.minecraft.world.level.block.Block;
@@ -128,12 +73,10 @@ import net.minecraft.world.level.chunk.storage.EntityStorage;
 import net.minecraft.world.level.dimension.BuiltinDimensionTypes;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.dimension.end.EndDragonFight;
-import net.minecraft.world.level.entity.EntityPersistentStorage;
 import net.minecraft.world.level.entity.EntityTickList;
 import net.minecraft.world.level.entity.EntityTypeTest;
 import net.minecraft.world.level.entity.LevelCallback;
 import net.minecraft.world.level.entity.LevelEntityGetter;
-import net.minecraft.world.level.entity.PersistentEntitySectionManager;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventDispatcher;
@@ -158,21 +101,32 @@ import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.ticks.LevelTicks;
-import org.slf4j.Logger;
 import org.bukkit.Bukkit;
-import org.bukkit.Location;
 import org.bukkit.WeatherType;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.generator.CustomWorldChunkManager;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.craftbukkit.util.WorldUUID;
 import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
-import org.bukkit.event.world.GenericGameEvent;
 import org.bukkit.event.world.TimeSkipEvent;
-// CraftBukkit end
-import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import org.slf4j.Logger;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.Writer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.Executor;
+import java.util.function.BooleanSupplier;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -192,7 +146,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final PrimaryLevelData serverLevelData; // CraftBukkit - type
-    final EntityTickList entityTickList;
+    public final EntityTickList entityTickList;
     //public final PersistentEntitySectionManager<Entity> entityManager; // Paper - rewrite chunk system
     private final GameEventDispatcher gameEventDispatcher;
     public boolean noSave;
@@ -204,7 +158,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     final Set<Mob> navigatingMobs;
     volatile boolean isUpdatingNavigations;
     protected final Raids raids;
-    private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents;
+    private final Deque<BlockEventData> blockEvents;
     private final List<BlockEventData> blockEventsToReschedule;
     private boolean handlingTick;
     private final List<CustomSpawner> customSpawners;
@@ -272,7 +226,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     public final void loadChunksForMoveAsync(AABB axisalignedbb, ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor.Priority priority,
                                              java.util.function.Consumer<List<net.minecraft.world.level.chunk.ChunkAccess>> onLoad) {
-        if (Thread.currentThread() != this.thread) {
+        if (Thread.currentThread() != this.thread && !Worker.isWorker()) {
             this.getChunkSource().mainThreadProcessor.execute(() -> {
                 this.loadChunksForMoveAsync(axisalignedbb, priority, onLoad);
             });
@@ -449,7 +403,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     // Paper end
 
     // Paper start - optimise checkDespawn
-    public final List<ServerPlayer> playersAffectingSpawning = new java.util.ArrayList<>();
+    public final List<ServerPlayer> playersAffectingSpawning = Lists.newCopyOnWriteArrayList();
     // Paper end - optimise checkDespawn
     // Paper start - optimise get nearest players for entity AI
     @Override
@@ -539,10 +493,10 @@ public class ServerLevel extends Level implements WorldGenLevel {
         this.entityTickList = new EntityTickList();
         this.blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
         this.fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
-        this.navigatingMobs = new ObjectOpenHashSet();
-        this.blockEvents = new ObjectLinkedOpenHashSet();
-        this.blockEventsToReschedule = new ArrayList(64);
-        this.dragonParts = new Int2ObjectOpenHashMap();
+        this.navigatingMobs = Sets.newConcurrentHashSet();
+        this.blockEvents = new ConcurrentLinkedDeque<>();
+        this.blockEventsToReschedule = Collections.synchronizedList(new ArrayList(64));
+        this.dragonParts = Int2ObjectMaps.synchronize(new Int2ObjectOpenHashMap());
         this.tickTime = flag1;
         this.server = minecraftserver;
         // Purpur start - enable/disable MobSpawners per world
@@ -712,71 +666,15 @@ public class ServerLevel extends Level implements WorldGenLevel {
         //timings.doSounds.stopTiming(); // Spigot // Purpur
         this.handlingTick = false;
         //gameprofilerfiller.pop(); // Purpur
-        boolean flag = true || !this.players.isEmpty() || !this.getForcedChunks().isEmpty(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
-
-        if (flag) {
-            this.resetEmptyTime();
-        }
-
-        if (flag || this.emptyTime++ < 300) {
-            //gameprofilerfiller.push("entities"); // Purpur
-            //timings.tickEntities.startTiming(); // Spigot // Purpur
-            if (this.dragonFight != null) {
-                //gameprofilerfiller.push("dragonFight"); // Purpur
-                this.dragonFight.tick();
-                //gameprofilerfiller.pop(); // Purpur
-            }
-
-            org.spigotmc.ActivationRange.activateEntities(this); // Spigot
-            //timings.entityTick.startTiming(); // Spigot // Purpur
-            this.entityTickList.forEach((entity) -> {
-                entity.activatedPriorityReset = false; // Pufferfish - DAB
-                if (!entity.isRemoved()) {
-                    if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
-                        entity.discard();
-                    } else {
-                        //gameprofilerfiller.push("checkDespawn"); // Purpur
-                        entity.checkDespawn();
-                        //gameprofilerfiller.pop(); // Purpur
-                        if (true || this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(entity.chunkPosition().toLong())) { // Paper - now always true if in the ticking list
-                            Entity entity1 = entity.getVehicle();
-
-                            if (entity1 != null) {
-                                if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
-                                    return;
-                                }
-
-                                entity.stopRiding();
-                            }
-
-                            //gameprofilerfiller.push("tick"); // Purpur
-                        // Pufferfish start - copied from this.guardEntityTick
-                        try {
-                            this.tickNonPassenger(entity); // Pufferfish - changed
-                            MinecraftServer.getServer().executeMidTickTasks(); // Tuinity - execute chunk tasks mid tick
-                        } catch (Throwable throwable) {
-                            if (throwable instanceof ThreadDeath) throw throwable; // Paper
-                            // Paper start - Prevent tile entity and entity crashes
-                            final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level.getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
-                            MinecraftServer.LOGGER.error(msg, throwable);
-                            getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, throwable)));
-                            entity.discard();
-                            // Paper end
-                        }
-                        // Pufferfish end
-                            //gameprofilerfiller.pop(); // Purpur
-                        }
-                    }
-                }
-            });
-            //timings.entityTick.stopTiming(); // Spigot // Purpur
-            //timings.tickEntities.stopTiming(); // Spigot // Purpur
-            //gameprofilerfiller.pop(); // Purpur
-            this.tickBlockEntities();
+        this.resetEmptyTime();
+        if (this.dragonFight != null) {
+            this.dragonFight.tick();
         }
-
-        //gameprofilerfiller.push("entityManagement"); // Purpur
-        //this.entityManager.tick(); // Paper - rewrite chunk system
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        this.entityTickList.forEach((entity) -> {
+            ServerEntityTickHook.callAsyncEntityTick(entity,this);
+        });
+        this.tickBlockEntities();
     }
 
     @Override
@@ -836,7 +734,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     }
 
-    private boolean shouldDiscardEntity(Entity entity) {
+    public boolean shouldDiscardEntity(Entity entity) {
         return !this.server.isSpawningAnimals() && (entity instanceof Animal || entity instanceof WaterAnimal) ? true : !this.server.areNpcsEnabled() && entity instanceof Npc;
     }
 
@@ -1296,13 +1194,10 @@ public class ServerLevel extends Level implements WorldGenLevel {
         } else { entity.inactiveTick(); } // Paper - EAR 2
         //this.getProfiler().pop(); // Purpur
         //} finally { timer.stopTiming(); } // Paper - timings // Purpur
-        Iterator iterator = entity.getPassengers().iterator();
-
-        while (iterator.hasNext()) {
-            Entity entity1 = (Entity) iterator.next();
 
-            this.tickPassenger(entity, entity1);
-        }
+            for (Entity entity1 : entity.getPassengers()) {
+                this.tickPassenger(entity, entity1);
+            }
         // } finally { timer.stopTiming(); } // Paper - timings - move up
         // Paper start - log detailed entity tick information
         } finally {
@@ -1341,11 +1236,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 }
                 // Paper end - EAR 2
                 //gameprofilerfiller.pop(); // Purpur
-                Iterator iterator = passenger.getPassengers().iterator();
-
-                while (iterator.hasNext()) {
-                    Entity entity2 = (Entity) iterator.next();
 
+                for (Entity entity2 : passenger.getPassengers()) {
                     this.tickPassenger(passenger, entity2);
                 }
 
@@ -1729,56 +1621,56 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
-        if (this.isUpdatingNavigations) {
-            String s = "recursive call to sendBlockUpdated";
+        synchronized (this.navigatingMobs){
+            if (this.isUpdatingNavigations) {
+                return;
+            }
 
-            Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
-        }
+            this.getChunkSource().blockChanged(pos);
+            if(this.paperConfig().misc.updatePathfindingOnBlockUpdate) { // Paper - option to disable pathfinding updates
+                VoxelShape voxelshape = oldState.getCollisionShape(this, pos);
+                VoxelShape voxelshape1 = newState.getCollisionShape(this, pos);
 
-        this.getChunkSource().blockChanged(pos);
-        if(this.paperConfig().misc.updatePathfindingOnBlockUpdate) { // Paper - option to disable pathfinding updates
-        VoxelShape voxelshape = oldState.getCollisionShape(this, pos);
-        VoxelShape voxelshape1 = newState.getCollisionShape(this, pos);
+                if (Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.NOT_SAME)) {
+                    List<PathNavigation> list = new ObjectArrayList();
+                    Iterator iterator = this.navigatingMobs.iterator();
 
-        if (Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.NOT_SAME)) {
-            List<PathNavigation> list = new ObjectArrayList();
-            Iterator iterator = this.navigatingMobs.iterator();
+                    while (iterator.hasNext()) {
+                        // CraftBukkit start - fix SPIGOT-6362
+                        Mob entityinsentient;
+                        try {
+                            entityinsentient = (Mob) iterator.next();
+                        } catch (java.util.ConcurrentModificationException ex) {
+                            // This can happen because the pathfinder update below may trigger a chunk load, which in turn may cause more navigators to register
+                            // In this case we just run the update again across all the iterators as the chunk will then be loaded
+                            // As this is a relative edge case it is much faster than copying navigators (on either read or write)
+                            this.sendBlockUpdated(pos, oldState, newState, flags);
+                            return;
+                        }
+                        // CraftBukkit end
+                        PathNavigation navigationabstract = entityinsentient.getNavigation();
 
-            while (iterator.hasNext()) {
-                // CraftBukkit start - fix SPIGOT-6362
-                Mob entityinsentient;
-                try {
-                    entityinsentient = (Mob) iterator.next();
-                } catch (java.util.ConcurrentModificationException ex) {
-                    // This can happen because the pathfinder update below may trigger a chunk load, which in turn may cause more navigators to register
-                    // In this case we just run the update again across all the iterators as the chunk will then be loaded
-                    // As this is a relative edge case it is much faster than copying navigators (on either read or write)
-                    this.sendBlockUpdated(pos, oldState, newState, flags);
-                    return;
-                }
-                // CraftBukkit end
-                PathNavigation navigationabstract = entityinsentient.getNavigation();
+                        if (navigationabstract.shouldRecomputePath(pos)) {
+                            list.add(navigationabstract);
+                        }
+                    }
 
-                if (navigationabstract.shouldRecomputePath(pos)) {
-                    list.add(navigationabstract);
-                }
-            }
+                    try {
+                        this.isUpdatingNavigations = true;
+                        iterator = list.iterator();
 
-            try {
-                this.isUpdatingNavigations = true;
-                iterator = list.iterator();
+                        while (iterator.hasNext()) {
+                            PathNavigation navigationabstract1 = (PathNavigation) iterator.next();
 
-                while (iterator.hasNext()) {
-                    PathNavigation navigationabstract1 = (PathNavigation) iterator.next();
+                            navigationabstract1.recomputePath();
+                        }
+                    } finally {
+                        this.isUpdatingNavigations = false;
+                    }
 
-                    navigationabstract1.recomputePath();
                 }
-            } finally {
-                this.isUpdatingNavigations = false;
-            }
-
+            } // Paper
         }
-        } // Paper
     }
 
     @Override
@@ -1845,10 +1737,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     private void runBlockEvents() {
         this.blockEventsToReschedule.clear();
-
-        while (!this.blockEvents.isEmpty()) {
-            BlockEventData blockactiondata = (BlockEventData) this.blockEvents.removeFirst();
-
+        BlockEventData blockactiondata;
+        while ((blockactiondata = (BlockEventData) this.blockEvents.pollFirst())!=null) {
             if (this.shouldTickBlocksAt(blockactiondata.pos())) {
                 if (this.doBlockEvent(blockactiondata)) {
                     this.server.getPlayerList().broadcast((Player) null, (double) blockactiondata.pos().getX(), (double) blockactiondata.pos().getY(), (double) blockactiondata.pos().getZ(), 64.0D, this.dimension(), new ClientboundBlockEventPacket(blockactiondata.pos(), blockactiondata.block(), blockactiondata.paramA(), blockactiondata.paramB()));
diff --git a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
index 660693c6dc0ef86f4013df980b6d0c11c03e46cd..1ea9699ce1f77a551a45fc06dad55df4cc1a4f4d 100644
--- a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
+++ b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
@@ -1,14 +1,9 @@
 package net.minecraft.server.level;
 
-import com.mojang.datafixers.util.Pair;
+import ca.spottedleaf.starlight.common.light.StarLightEngine;
 import com.mojang.logging.LogUtils;
-import it.unimi.dsi.fastutil.objects.ObjectArrayList;
-import it.unimi.dsi.fastutil.objects.ObjectList;
-import it.unimi.dsi.fastutil.objects.ObjectListIterator;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.function.IntSupplier;
-import javax.annotation.Nullable;
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -17,21 +12,17 @@ import net.minecraft.util.thread.ProcessorMailbox;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.LightLayer;
 import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.DataLayer;
-import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.LightChunkGetter;
+import net.minecraft.world.level.lighting.LayerLightEventListener;
 import net.minecraft.world.level.lighting.LevelLightEngine;
 import org.slf4j.Logger;
 
-// Paper start
-import ca.spottedleaf.starlight.common.light.StarLightEngine;
-import io.papermc.paper.util.CoordinateUtils;
+import javax.annotation.Nullable;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.IntSupplier;
 import java.util.function.Supplier;
-import net.minecraft.world.level.lighting.LayerLightEventListener;
-import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongArrayList;
-import it.unimi.dsi.fastutil.longs.LongIterator;
-import net.minecraft.world.level.chunk.ChunkStatus;
 // Paper end
 
 public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCloseable {
@@ -145,20 +136,30 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
             return;
         }
 
-        final int references = this.chunksBeingWorkedOn.addTo(key, 1);
+        int references;
+        synchronized (this.chunksBeingWorkedOn){
+            references = this.chunksBeingWorkedOn.addTo(key, 1);
+        }
         if (references == 0) {
             final ChunkPos pos = new ChunkPos(chunkX, chunkZ);
             world.getChunkSource().addRegionTicket(ca.spottedleaf.starlight.common.light.StarLightInterface.CHUNK_WORK_TICKET, pos, 0, pos);
         }
 
         updateFuture.thenAcceptAsync((final Void ignore) -> {
-            final int newReferences = this.chunksBeingWorkedOn.get(key);
+            int newReferences;
+            synchronized (this.chunksBeingWorkedOn){
+                newReferences = this.chunksBeingWorkedOn.get(key);
+            }
             if (newReferences == 1) {
-                this.chunksBeingWorkedOn.remove(key);
+                synchronized (this.chunksBeingWorkedOn){
+                    this.chunksBeingWorkedOn.remove(key);
+                }
                 final ChunkPos pos = new ChunkPos(chunkX, chunkZ);
                 world.getChunkSource().removeRegionTicket(ca.spottedleaf.starlight.common.light.StarLightInterface.CHUNK_WORK_TICKET, pos, 0, pos);
             } else {
-                this.chunksBeingWorkedOn.put(key, newReferences - 1);
+                synchronized (this.chunksBeingWorkedOn){
+                    this.chunksBeingWorkedOn.put(key, newReferences - 1);
+                }
             }
         }, world.getChunkSource().chunkMap.mainThreadExecutor).whenComplete((final Void ignore, final Throwable thr) -> {
             if (thr != null) {
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 83701fbfaa56a232593ee8f11a3afb8941238bfa..0eadacb873658a0c7bd9ab24f191bc75eaebcaca 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -3,11 +3,15 @@ package net.minecraft.util.thread;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Queues;
 import com.mojang.logging.LogUtils;
+
+import java.util.Deque;
 import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.Executor;
 import java.util.concurrent.locks.LockSupport;
+import java.util.concurrent.locks.StampedLock;
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
 import net.minecraft.util.profiling.metrics.MetricCategory;
@@ -19,7 +23,8 @@ import org.slf4j.Logger;
 public abstract class BlockableEventLoop<R extends Runnable> implements ProfilerMeasured, ProcessorHandle<R>, Executor {
     private final String name;
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Queue<R> pendingRunnables = Queues.newConcurrentLinkedQueue();
+    private final Deque<R> pendingRunnables = new ConcurrentLinkedDeque<>();
+    private final StampedLock lock = new StampedLock();
     private int blockingCount;
 
     protected BlockableEventLoop(String name) {
@@ -117,13 +122,14 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public boolean pollTask() {
-        R runnable = this.pendingRunnables.peek();
+        R runnable = this.pendingRunnables.poll();
         if (runnable == null) {
             return false;
         } else if (this.blockingCount == 0 && !this.shouldRun(runnable)) {
+            this.pendingRunnables.addFirst(runnable);
             return false;
         } else {
-            this.doRunTask(this.pendingRunnables.remove());
+            this.doRunTask(runnable);
             return true;
         }
     }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index af5addc0b647ebb0033048fdc48866071a13f829..2c82dafc4585590814f81bfb0c91d577353a0da8 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -25,6 +25,8 @@ import java.util.function.BiConsumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.objects.Object2DoubleMaps;
 import net.minecraft.BlockUtil;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -165,76 +167,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     }
 
     // Paper start
-    public static RandomSource SHARED_RANDOM = new RandomRandomSource();
-    private static final class RandomRandomSource extends java.util.Random implements net.minecraft.world.level.levelgen.BitRandomSource {
-        private boolean locked = false;
-
-        @Override
-        public synchronized void setSeed(long seed) {
-            if (locked) {
-                LOGGER.error("Ignoring setSeed on Entity.SHARED_RANDOM", new Throwable());
-            } else {
-                super.setSeed(seed);
-                locked = true;
-            }
-        }
-
-        @Override
-        public RandomSource fork() {
-            return new net.minecraft.world.level.levelgen.LegacyRandomSource(this.nextLong());
-        }
-
-        @Override
-        public net.minecraft.world.level.levelgen.PositionalRandomFactory forkPositional() {
-            return new net.minecraft.world.level.levelgen.LegacyRandomSource.LegacyPositionalRandomFactory(this.nextLong());
-        }
-
-        // these below are added to fix reobf issues that I don't wanna deal with right now
-        @Override
-        public int next(int bits) {
-            return super.next(bits);
-        }
-
-        @Override
-        public int nextInt(int origin, int bound) {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextInt(origin, bound);
-        }
-
-        @Override
-        public long nextLong() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextLong();
-        }
-
-        @Override
-        public int nextInt() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextInt();
-        }
-
-        @Override
-        public int nextInt(int bound) {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextInt(bound);
-        }
-
-        @Override
-        public boolean nextBoolean() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextBoolean();
-        }
-
-        @Override
-        public float nextFloat() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextFloat();
-        }
-
-        @Override
-        public double nextDouble() {
-            return net.minecraft.world.level.levelgen.BitRandomSource.super.nextDouble();
-        }
-
-        @Override
-        public double nextGaussian() {
-            return super.nextGaussian();
-        }
-    }
+    public static RandomSource SHARED_RANDOM = RandomSource.create();
     // Paper end
     public org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason; // Paper
 
@@ -582,14 +515,14 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         this.nextStep = 1.0F;
         this.random = world == null || world.purpurConfig.entitySharedRandom ? SHARED_RANDOM : RandomSource.create(); // Paper // Purpur
         this.remainingFireTicks = -this.getFireImmuneTicks();
-        this.fluidHeight = new Object2DoubleArrayMap(2);
-        this.fluidOnEyes = new HashSet();
+        this.fluidHeight = Object2DoubleMaps.synchronize(new Object2DoubleArrayMap(2));
+        this.fluidOnEyes = Sets.newConcurrentHashSet();
         this.firstTick = true;
         this.levelCallback = EntityInLevelCallback.NULL;
         this.packetPositionCodec = new VecDeltaCodec();
         this.uuid = Mth.createInsecureUUID(this.random);
         this.stringUUID = this.uuid.toString();
-        this.tags = Sets.newHashSet();
+        this.tags = Sets.newConcurrentHashSet();
         this.pistonDeltas = new double[]{0.0D, 0.0D, 0.0D};
         this.feetBlockState = null;
         this.type = type;
@@ -4474,6 +4407,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         // Paper start
         this.setPosRaw(x, y, z, false);
     }
+
     public final void setPosRaw(double x, double y, double z, boolean forceBoundingBoxUpdate) {
         // Paper start - block invalid positions
         if (!checkPosition(this, x, y, z)) {
@@ -4481,12 +4415,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         }
         // Paper end - block invalid positions
         // Paper end
-        // Paper start - rewrite chunk system
-        if (this.updatingSectionStatus) {
-            LOGGER.error("Refusing to update position for entity " + this + " to position " + new Vec3(x, y, z) + " since it is processing a section status update", new Throwable());
-            return;
-        }
-        // Paper end - rewrite chunk system
         // Paper start - fix MC-4
         if (this instanceof ItemEntity) {
             if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.fixEntityPositionDesync) {
@@ -4602,10 +4530,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public final void setRemoved(Entity.RemovalReason reason) {
         // Paper start - rewrite chunk system
         io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot remove entity off-main");
-        if (this.updatingSectionStatus) {
-            LOGGER.warn("Entity " + this + " is currently prevented from being added/removed to world since it is processing section status updates", new Throwable());
-            return;
-        }
         // Paper end - rewrite chunk system
         if (this.removalReason == null) {
             this.removalReason = reason;
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index fea53e56ab78f68fd0ff55267a90cdb11e4e7812..ac3f3756b23b61095d632029504053e952e1d0f9 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.entity;
 
+import cc.keyimc.keyi.utils.EntityPositionCache;
 import com.destroystokyo.paper.event.player.PlayerArmorChangeEvent; // Paper
 import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableList;
@@ -17,6 +18,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
@@ -124,7 +126,6 @@ import net.minecraft.world.scores.PlayerTeam;
 import org.slf4j.Logger;
 
 // CraftBukkit start
-import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Set;
 import com.google.common.base.Function;
@@ -181,7 +182,7 @@ public abstract class LivingEntity extends Entity {
     public static final float EXTRA_RENDER_CULLING_SIZE_WITH_BIG_HAT = 0.5F;
     private final AttributeMap attributes;
     public CombatTracker combatTracker = new CombatTracker(this);
-    public final Map<MobEffect, MobEffectInstance> activeEffects = Maps.newHashMap();
+    public final Map<MobEffect, MobEffectInstance> activeEffects = Maps.newConcurrentMap();
     private final NonNullList<ItemStack> lastHandItemStacks;
     private final NonNullList<ItemStack> lastArmorItemStacks;
     public boolean swinging;
@@ -258,7 +259,7 @@ public abstract class LivingEntity extends Entity {
     public int expToDrop;
     public float safeFallDistance = 3.0F; // Purpur
     public boolean forceDrops;
-    public ArrayList<org.bukkit.inventory.ItemStack> drops = new ArrayList<org.bukkit.inventory.ItemStack>();
+    public List<org.bukkit.inventory.ItemStack> drops = new CopyOnWriteArrayList<>();
     public final org.bukkit.craftbukkit.attribute.CraftAttributeMap craftAttributes;
     public boolean collides = true;
     public Set<UUID> collidableExemptions = new HashSet<>();
@@ -888,7 +889,11 @@ public abstract class LivingEntity extends Entity {
 
     // CraftBukkit start
     private boolean isTickingEffects = false;
-    private List<ProcessableEffect> effectsToProcess = Lists.newArrayList();
+    private List<ProcessableEffect> effectsToProcess = Lists.newCopyOnWriteArrayList();
+
+    public double distanceToSqr(EntityPositionCache entityPositionCache) {
+        return this.distanceToSqr(entityPositionCache.getX(),entityPositionCache.getY(),entityPositionCache.getZ());
+    }
 
     private static class ProcessableEffect {
 
@@ -1831,7 +1836,7 @@ public abstract class LivingEntity extends Entity {
             }
         }); // Paper end
         this.postDeathDropItems(deathEvent); // Paper
-        this.drops = new ArrayList<>();
+        this.drops = new CopyOnWriteArrayList<>();
         // CraftBukkit end
 
         // this.dropInventory();// CraftBukkit - moved up
@@ -2015,6 +2020,10 @@ public abstract class LivingEntity extends Entity {
             BlockPos blockposition = this.blockPosition();
             BlockState iblockdata = this.getFeetBlockState();
 
+            if (iblockdata == null){
+                return false;
+            }
+
             if (iblockdata.is(BlockTags.CLIMBABLE)) {
                 this.lastClimbablePos = Optional.of(blockposition);
                 return true;
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index f6891970aebfe0095e37cca532fd6b971f5d1ee7..1ca4b9fba973278e084d2197b38e1d2ddaa3a43d 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -860,7 +860,9 @@ public abstract class Mob extends LivingEntity {
             // Paper start - optimise checkDespawn
             Player entityhuman = this.level.findNearbyPlayer(this, level.paperConfig().entities.spawning.despawnRanges.get(this.getType().getCategory()).hard() + 1, EntitySelector.PLAYER_AFFECTS_SPAWNING); // Paper
             if (entityhuman == null) {
-                entityhuman = ((ServerLevel)this.level).playersAffectingSpawning.isEmpty() ? null : ((ServerLevel)this.level).playersAffectingSpawning.get(0);
+                synchronized (((ServerLevel) this.level).playersAffectingSpawning) {
+                    entityhuman = ((ServerLevel) this.level).playersAffectingSpawning.isEmpty() ? null : ((ServerLevel) this.level).playersAffectingSpawning.get(0);
+                }
             }
             // Paper end - optimise checkDespawn
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index 210a0bee1227e4671909dd553ab22027cfc868fb..c9fe09393f1da6687e4950ddb37069a4337e0f5d 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -20,8 +20,8 @@ import org.slf4j.Logger;
 
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Map<Attribute, AttributeInstance> attributes = Maps.newHashMap();
-    private final Set<AttributeInstance> dirtyAttributes = Sets.newHashSet();
+    private final Map<Attribute, AttributeInstance> attributes = Maps.newConcurrentMap();
+    private final Set<AttributeInstance> dirtyAttributes = Sets.newConcurrentHashSet();
     private final AttributeSupplier supplier;
     private final java.util.function.Function<Attribute, AttributeInstance> createInstance; // Pufferfish
     private final net.minecraft.world.entity.LivingEntity entity; // Purpur
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/ShufflingList.java b/src/main/java/net/minecraft/world/entity/ai/behavior/ShufflingList.java
index fe3ab3d388f0481fb0db06b7f730f868dbf8e8a5..ac006bacbe8715e5c272c69afd1edab45a6511e8 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/ShufflingList.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/ShufflingList.java
@@ -25,7 +25,7 @@ public class ShufflingList<U> implements Iterable<U> {
     public ShufflingList(boolean isUnsafe) {
         this.isUnsafe = isUnsafe;
         // Paper end
-        this.entries = Lists.newArrayList();
+        this.entries = Lists.newCopyOnWriteArrayList();
     }
 
     private ShufflingList(List<ShufflingList.WeightedEntry<U>> list) {
@@ -35,7 +35,7 @@ public class ShufflingList<U> implements Iterable<U> {
     private ShufflingList(List<ShufflingList.WeightedEntry<U>> list, boolean isUnsafe) {
         this.isUnsafe = isUnsafe;
         // Paper end
-        this.entries = Lists.newArrayList(list);
+        this.entries = Lists.newCopyOnWriteArrayList(list);
     }
 
     public static <U> Codec<ShufflingList<U>> codec(Codec<U> codec) {
@@ -44,12 +44,12 @@ public class ShufflingList<U> implements Iterable<U> {
         });
     }
 
-    public ShufflingList<U> add(U data, int weight) {
+    public synchronized ShufflingList<U> add(U data, int weight) {
         this.entries.add(new ShufflingList.WeightedEntry<>(data, weight));
         return this;
     }
 
-    public ShufflingList<U> shuffle() {
+    public synchronized ShufflingList<U> shuffle() {
         // Paper start - make concurrent safe, work off a clone of the list
         List<ShufflingList.WeightedEntry<U>> list = this.isUnsafe ? Lists.newArrayList(this.entries) : this.entries;
         list.forEach(entry -> entry.setRandom(this.random.nextFloat()));
@@ -58,17 +58,17 @@ public class ShufflingList<U> implements Iterable<U> {
         // Paper end
     }
 
-    public Stream<U> stream() {
+    public synchronized Stream<U> stream() {
         return this.entries.stream().map(ShufflingList.WeightedEntry::getData);
     }
 
     @Override
-    public Iterator<U> iterator() {
+    public synchronized Iterator<U> iterator() {
         return Iterators.transform(this.entries.iterator(), ShufflingList.WeightedEntry::getData);
     }
 
     @Override
-    public String toString() {
+    public synchronized String toString() {
         return "ShufflingList[" + this.entries + "]";
     }
 
@@ -90,16 +90,16 @@ public class ShufflingList<U> implements Iterable<U> {
             this.randWeight = -Math.pow((double)random, (double)(1.0F / (float)this.weight));
         }
 
-        public T getData() {
+        public synchronized T getData() {
             return this.data;
         }
 
-        public int getWeight() {
+        public synchronized int getWeight() {
             return this.weight;
         }
 
         @Override
-        public String toString() {
+        public synchronized String toString() {
             return this.weight + ":" + this.data;
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index 02978315bc2b828cc603ce7478408f3f82c249c2..fc26edc5082f701e6450ca9abf78423840cd773c 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -3,11 +3,8 @@ package net.minecraft.world.entity.ai.goal;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Sets;
 import com.mojang.logging.LogUtils;
-import java.util.EnumMap;
-import java.util.EnumSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
+
+import java.util.*;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -27,8 +24,8 @@ public class GoalSelector {
             return false;
         }
     };
-    private final Map<Goal.Flag, WrappedGoal> lockedFlags = new EnumMap<>(Goal.Flag.class);
-    private final Set<WrappedGoal> availableGoals = Sets.newLinkedHashSet();
+    private final Map<Goal.Flag, WrappedGoal> lockedFlags = Collections.synchronizedMap(new EnumMap<>(Goal.Flag.class));
+    private final Set<WrappedGoal> availableGoals = Sets.newConcurrentHashSet();
     private final Supplier<ProfilerFiller> profiler;
     private final EnumSet<Goal.Flag> disabledFlags = EnumSet.noneOf(Goal.Flag.class); // Paper unused, but dummy to prevent plugins from crashing as hard. Theyll need to support paper in a special case if this is super important, but really doesn't seem like it would be.
     private final com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<net.minecraft.world.entity.ai.goal.Goal.Flag> goalTypes = new com.destroystokyo.paper.util.set.OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from pathfindergoalselector
@@ -114,14 +111,7 @@ public class GoalSelector {
             }
         }
 
-        Iterator<Map.Entry<Goal.Flag, WrappedGoal>> iterator = this.lockedFlags.entrySet().iterator();
-
-        while(iterator.hasNext()) {
-            Map.Entry<Goal.Flag, WrappedGoal> entry = iterator.next();
-            if (!entry.getValue().isRunning()) {
-                iterator.remove();
-            }
-        }
+        this.lockedFlags.entrySet().removeIf(entry -> !entry.getValue().isRunning());
 
         //profilerFiller.pop(); // Purpur
         //profilerFiller.push("goalUpdate"); // Purpur
diff --git a/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java b/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
index 097007c1c25ba55d9916fc820dd1d1149d81f6f4..b15b47041ad891deca9ff9b3bc6d196598f27a68 100644
--- a/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
+++ b/src/main/java/net/minecraft/world/entity/ai/gossip/GossipContainer.java
@@ -30,7 +30,7 @@ import org.slf4j.Logger;
 public class GossipContainer {
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final int DISCARD_THRESHOLD = 2;
-    public final Map<UUID, GossipContainer.EntityGossips> gossips = Maps.newHashMap();
+    public final Map<UUID, GossipContainer.EntityGossips> gossips = Maps.newConcurrentMap();
 
     @VisibleForDebug
     public Map<UUID, Object2IntMap<GossipType>> getGossipEntries() {
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
index 8db20db72cd51046213625fac46c35854c59ec5d..4d40526cc90c19ff5a1569c8d6d828a0d0b73ccb 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
@@ -3,6 +3,7 @@ package net.minecraft.world.entity.ai.sensing;
 import com.google.common.collect.ImmutableSet;
 import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.Long2LongMaps;
 import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
 import java.util.Optional;
 import java.util.Set;
@@ -23,7 +24,7 @@ public class NearestBedSensor extends Sensor<Mob> {
     private static final int CACHE_TIMEOUT = 40;
     private static final int BATCH_SIZE = 5;
     private static final int RATE = 20;
-    private final Long2LongMap batchCache = new Long2LongOpenHashMap();
+    private final Long2LongMap batchCache = Long2LongMaps.synchronize(new Long2LongOpenHashMap());
     private int triedCount;
     private long lastUpdate;
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestItemSensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestItemSensor.java
index 2c4517850a9692f1c2b1332b58e8312fe1166772..bee1aa7eded53b3302f39053bfd9c4af5f3008c3 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestItemSensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestItemSensor.java
@@ -27,12 +27,11 @@ public class NearestItemSensor extends Sensor<Mob> {
         List<ItemEntity> list = world.getEntitiesOfClass(ItemEntity.class, entity.getBoundingBox().inflate(32.0D, 16.0D, 32.0D), (itemEntity) -> {
             return itemEntity.closerThan(entity, 9.0D) && entity.wantsToPickUp(itemEntity.getItem()); // Paper - move predicate into getEntities
         });
-        list.sort((e1, e2) -> Double.compare(entity.distanceToSqr(e1), entity.distanceToSqr(e2))); // better to take the sort perf hit than using line of sight more than we need to.
+        list.sort(Comparator.comparingDouble(entity::distanceToSqr)); // better to take the sort perf hit than using line of sight more than we need to.
         // Paper start - remove streams
         // Paper start - remove streams in favour of lists
         ItemEntity nearest = null;
-        for (int i = 0; i < list.size(); i++) {
-            ItemEntity entityItem = list.get(i);
+        for (ItemEntity entityItem : list) {
             if (entity.hasLineOfSight(entityItem)) {
                 // Paper end - remove streams
                 nearest = entityItem;
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
index 75d9c4f011b5a97def215784c92bb57bbb35d06b..219e210611412ee00942488684d7bbe8920d157e 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
@@ -1,11 +1,13 @@
 package net.minecraft.world.entity.ai.sensing;
 
+import cc.keyimc.keyi.utils.EntityPositionCache;
 import com.google.common.collect.ImmutableSet;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Optional;
-import java.util.Set;
-import java.util.stream.Collectors;
+
+import java.util.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectLists;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.EntitySelector;
 import net.minecraft.world.entity.LivingEntity;
@@ -14,6 +16,9 @@ import net.minecraft.world.entity.ai.memory.MemoryModuleType;
 import net.minecraft.world.entity.player.Player;
 
 public class PlayerSensor extends Sensor<LivingEntity> {
+    private final List<Player> playerList = ObjectLists.synchronize(new ObjectArrayList<>());
+    private final AtomicBoolean calling = new AtomicBoolean();
+
     @Override
     public Set<MemoryModuleType<?>> requires() {
         return ImmutableSet.of(MemoryModuleType.NEAREST_PLAYERS, MemoryModuleType.NEAREST_VISIBLE_PLAYER, MemoryModuleType.NEAREST_VISIBLE_ATTACKABLE_PLAYER);
@@ -21,30 +26,51 @@ public class PlayerSensor extends Sensor<LivingEntity> {
 
     @Override
     protected void doTick(ServerLevel world, LivingEntity entity) {
-        // Paper start - remove streams
-        List<Player> players = (List)world.getNearbyPlayers(entity, entity.getX(), entity.getY(), entity.getZ(), 16.0D, EntitySelector.NO_SPECTATORS);
-        players.sort((e1, e2) -> Double.compare(entity.distanceToSqr(e1), entity.distanceToSqr(e2)));
-        Brain<?> brain = entity.getBrain();
-
-        brain.setMemory(MemoryModuleType.NEAREST_PLAYERS, players);
-
-        Player firstTargetable = null;
-        Player firstAttackable = null;
-        for (int index = 0, len = players.size(); index < len; ++index) {
-            Player player = players.get(index);
-            if (firstTargetable == null && isEntityTargetable(entity, player)) {
-                firstTargetable = player;
-            }
-            if (firstAttackable == null && isEntityAttackable(entity, player)) {
-                firstAttackable = player;
-            }
+        if (this.calling.get()){
+            return;
+        }
+
+        this.calling.set(true);
+        try {
+            // Paper start - remove streams
+            List<EntityPositionCache> playersPosCaches = new ArrayList<>(List.of(world
+                    .getNearbyPlayers(entity, entity.getX(), entity.getY(), entity.getZ(), 16.0D, EntitySelector.NO_SPECTATORS)
+                    .stream()
+                    .map(EntityPositionCache::new)
+                    .toArray(EntityPositionCache[]::new)));
+
+            final EntityPositionCache entityPositionCache = new EntityPositionCache(entity);
+
+            playersPosCaches.sort(Comparator.comparingDouble(entityPositionCache::distanceToSqr));
+
+            final List<Player> players = playersPosCaches
+                    .stream()
+                    .map(cache -> ((Player) cache.getCurrentEntity()))
+                    .toList();
+
+            Brain<?> brain = entity.getBrain();
+
+            brain.setMemory(MemoryModuleType.NEAREST_PLAYERS, players);
+
+            Player firstTargetable = null;
+            Player firstAttackable = null;
+            for (Player player : players) {
+                if (firstTargetable == null && isEntityTargetable(entity, player)) {
+                    firstTargetable = player;
+                }
+                if (firstAttackable == null && isEntityAttackable(entity, player)) {
+                    firstAttackable = player;
+                }
 
-            if (firstAttackable != null && firstTargetable != null) {
-                break;
+                if (firstAttackable != null && firstTargetable != null) {
+                    break;
+                }
             }
+            brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_PLAYER, firstTargetable);
+            brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_ATTACKABLE_PLAYER, Optional.ofNullable(firstAttackable));
+            // Paper end - remove streams
+        }finally {
+            this.calling.set(false);
         }
-        brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_PLAYER, firstTargetable);
-        brain.setMemory(MemoryModuleType.NEAREST_VISIBLE_ATTACKABLE_PLAYER, Optional.ofNullable(firstAttackable));
-        // Paper end - remove streams
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java
index 9babe636176da3c40598eb5bdac0919a1704eaa0..58c6b1f67aedf5ab2167fd070604fc0d8f710435 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java
@@ -2,13 +2,14 @@ package net.minecraft.world.entity.ai.sensing;
 
 import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
 import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.ints.IntSets;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.Mob;
 
 public class Sensing {
     private final Mob mob;
-    private final IntSet seen = new IntOpenHashSet();
-    private final IntSet unseen = new IntOpenHashSet();
+    private final IntSet seen = IntSets.synchronize(new IntOpenHashSet());
+    private final IntSet unseen = IntSets.synchronize(new IntOpenHashSet());
 
     public Sensing(Mob owner) {
         this.mob = owner;
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
index 9f138bc471b5c2a4fa813ff943dbe34018b8df74..5c8a90f8536c9291df5891d8c75de963b75ec4bd 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiSection.java
@@ -7,6 +7,7 @@ import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import it.unimi.dsi.fastutil.shorts.Short2ObjectMap;
+import it.unimi.dsi.fastutil.shorts.Short2ObjectMaps;
 import it.unimi.dsi.fastutil.shorts.Short2ObjectOpenHashMap;
 import java.util.List;
 import java.util.Map;
@@ -25,8 +26,9 @@ import org.slf4j.Logger;
 
 public class PoiSection {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Short2ObjectMap<PoiRecord> records = new Short2ObjectOpenHashMap<>();
-    private final Map<Holder<PoiType>, Set<PoiRecord>> byType = Maps.newHashMap(); public final Map<Holder<PoiType>, Set<PoiRecord>> getData() { return this.byType; } // Paper - public accessor
+    private final Short2ObjectMap<PoiRecord> records = Short2ObjectMaps.synchronize(new Short2ObjectOpenHashMap<>());
+    private final Map<Holder<PoiType>, Set<PoiRecord>> byType = Maps.newConcurrentMap();
+    public final Map<Holder<PoiType>, Set<PoiRecord>> getData() { return this.byType; } // Paper - public accessor
     private final Runnable setDirty;
     private boolean isValid;
     public final Optional<PoiSection> noAllocateOptional = Optional.of(this); // Paper - rewrite chunk system
diff --git a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
index fbde463c789d728150f7963ab1598a811c2522c1..575a4ece24401d47624bb21212454de1ba546f95 100644
--- a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
@@ -4,6 +4,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.UUID;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
@@ -246,21 +248,24 @@ public class ItemEntity extends Entity {
         this.setDeltaMovement(vec3d.x * 0.949999988079071D, vec3d.y + (double) (vec3d.y < 0.05999999865889549D ? 5.0E-4F : 0.0F), vec3d.z * 0.949999988079071D);
     }
 
+    private final Lock mergeLock = new ReentrantLock();
+
     private void mergeWithNeighbours() {
-        if (this.isMergable()) {
-            // Spigot start
-            double radius = level.spigotConfig.itemMerge;
-            List<ItemEntity> list = this.level.getEntitiesOfClass(ItemEntity.class, this.getBoundingBox().inflate(radius, radius - 0.5D, radius), (entityitem) -> {
-                // Spigot end
-                return entityitem != this && entityitem.isMergable();
-            });
-            Iterator iterator = list.iterator();
-
-            while (iterator.hasNext()) {
-                ItemEntity entityitem = (ItemEntity) iterator.next();
-
-                if (entityitem.isMergable()) {
-                    // Paper Start - Fix items merging through walls
+        if (!this.mergeLock.tryLock()){
+            return;
+        }
+        try {
+            if (this.isMergable()) {
+                // Spigot start
+                double radius = level.spigotConfig.itemMerge;
+                List<ItemEntity> list = this.level.getEntitiesOfClass(ItemEntity.class, this.getBoundingBox().inflate(radius, radius - 0.5D, radius), (entityitem) -> {
+                    // Spigot end
+                    return entityitem != this && entityitem.isMergable();
+                });
+
+                for (ItemEntity entityitem : list) {
+                    if (entityitem.isMergable()) {
+                        // Paper Start - Fix items merging through walls
                         if (this.level.paperConfig().fixes.fixItemsMergingThroughWalls) {
                             // Pufferfish start - skip the allocations
                             if (!KGlobalConfig.getInstance().useFastItemMergingRaytracing) {
@@ -270,17 +275,19 @@ public class ItemEntity extends Entity {
                                 if (rayTraceResult.getType() == net.minecraft.world.phys.HitResult.Type.BLOCK) continue;
                             }
                             if (level.rayTraceDirect(this.position(), entityitem.position(), net.minecraft.world.phys.shapes.CollisionContext.of(this)) ==
-                                net.minecraft.world.phys.HitResult.Type.BLOCK) continue;
+                                    net.minecraft.world.phys.HitResult.Type.BLOCK) continue;
                             // Pufferfish end
                         }
-                    // Paper End
-                    this.tryToMerge(entityitem);
-                    if (this.isRemoved()) {
-                        break;
+                        // Paper End
+                        this.tryToMerge(entityitem);
+                        if (this.isRemoved()) {
+                            break;
+                        }
                     }
                 }
             }
-
+        }finally {
+            this.mergeLock.unlock();
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 7222ff43de1b570458f2513fe1a44d97a09d0799..d627a2d8b30072780ed6786d63c2a10acd536e7d 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -249,7 +249,9 @@ public final class ItemStack {
     }
 
     private void updateEmptyCacheFlag() {
-        if (this.emptyCacheFlag && this == ItemStack.EMPTY) throw new AssertionError("TRAP"); // CraftBukkit
+        if (this.emptyCacheFlag && this == ItemStack.EMPTY){
+            return;
+        }//throw new AssertionError("TRAP"); // CraftBukkit
         this.emptyCacheFlag = false;
         this.emptyCacheFlag = this.isEmpty();
     }
diff --git a/src/main/java/net/minecraft/world/level/Explosion.java b/src/main/java/net/minecraft/world/level/Explosion.java
index 3c9e0cee78deeae6b47a186f1bfc47f3956ec9c7..6024f58a3994cefda5f7deddcd92d017f57bea5a 100644
--- a/src/main/java/net/minecraft/world/level/Explosion.java
+++ b/src/main/java/net/minecraft/world/level/Explosion.java
@@ -4,12 +4,15 @@ import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectList;
 import it.unimi.dsi.fastutil.objects.ObjectListIterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.objects.ObjectLists;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.particles.ParticleTypes;
@@ -81,9 +84,9 @@ public class Explosion {
     }
 
     public Explosion(Level world, @Nullable Entity entity, @Nullable DamageSource damageSource, @Nullable ExplosionDamageCalculator behavior, double x, double y, double z, float power, boolean createFire, Explosion.BlockInteraction destructionType) {
-        this.random = RandomSource.create();
-        this.toBlow = new ObjectArrayList();
-        this.hitPlayers = Maps.newHashMap();
+        this.random = RandomSource.createThreadSafe();
+        this.toBlow = new ObjectArrayList<>();
+        this.hitPlayers = Maps.newConcurrentMap();
         this.level = world;
         this.source = entity;
         this.radius = (float) (world.purpurConfig.explosionClampRadius ? Math.max(power, 0.0) : power); // CraftBukkit - clamp bad values // Purpur
@@ -396,14 +399,10 @@ public class Explosion {
         }
 
         if (this.fire) {
-            ObjectListIterator objectlistiterator1 = this.toBlow.iterator();
-
-            while (objectlistiterator1.hasNext()) {
-                BlockPos blockposition2 = (BlockPos) objectlistiterator1.next();
-
+            for (BlockPos blockposition2 : this.toBlow) {
                 if (this.random.nextInt(3) == 0 && this.level.getBlockState(blockposition2).isAir() && this.level.getBlockState(blockposition2.below()).isSolidRender(this.level, blockposition2.below())) {
                     // CraftBukkit start - Ignition by explosion
-                    if (!org.bukkit.craftbukkit.event.CraftEventFactory.callBlockIgniteEvent(this.level, blockposition2.getX(), blockposition2.getY(), blockposition2.getZ(), this).isCancelled()) {
+                    if (!CraftEventFactory.callBlockIgniteEvent(this.level, blockposition2.getX(), blockposition2.getY(), blockposition2.getZ(), this).isCancelled()) {
                         this.level.setBlockAndUpdate(blockposition2, BaseFireBlock.getState(this.level, blockposition2));
                     }
                     // CraftBukkit end
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index a9289072b048095330ea32d7c965e8dda61a36fc..f1f9f9983ab258b9268450ee65d4cb51bb74e668 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1,11 +1,10 @@
 package net.minecraft.world.level;
 
-import co.aikar.timings.Timing;
-import co.aikar.timings.Timings;
+import cc.keyimc.keyi.concurrent.thread.Worker;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
-import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
 import java.util.Iterator;
@@ -17,7 +16,6 @@ import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -35,15 +33,12 @@ import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -81,7 +76,6 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.scores.Scoreboard;
 
 // CraftBukkit start
-import java.util.HashMap;
 import java.util.Map;
 import net.minecraft.network.protocol.game.ClientboundSetBorderCenterPacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
@@ -89,17 +83,14 @@ import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDelayPacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDistancePacket;
 import org.bukkit.Bukkit;
-import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CapturedBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftSpawnCategory;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
-import org.bukkit.event.world.GenericGameEvent;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -180,7 +171,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
-    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
+    public final Map<Explosion.CacheKey, Float> explosionDensityCache = Maps.newConcurrentMap(); // Paper - Optimize explosions
     public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Move from Map in BlockRedstoneTorch to here
 
     // Paper start - fix and optimise world upgrading
@@ -1163,7 +1154,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         }
         // Paper end
         // CraftBukkit end
-        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && !io.papermc.paper.util.TickThread.isTickThread() ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE)); // Paper - rewrite chunk system
+        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && !io.papermc.paper.util.TickThread.isTickThread() && !Worker.isWorker() ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE)); // Paper - rewrite chunk system
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index e254b2d04e4fc1dc76c26f61ea38aeb27755143f..948abd93c64a5b3679f3552945d7a9a2edaf7c3f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -17,6 +17,9 @@ import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.shorts.ShortLists;
+import net.himeki.mcmtfabric.parallelised.fastutil.ConcurrentShortHashSet;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -384,7 +387,7 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
 
     public static ShortList getOrCreateOffsetList(ShortList[] lists, int index) {
         if (lists[index] == null) {
-            lists[index] = new ShortArrayList();
+            lists[index] = ShortLists.synchronize(new ShortArrayList());
         }
 
         return lists[index];
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 9168e70d7d478254ad45e913885d79391a2338ae..8b1648e472ee6b9214fab8f26f9b3f9a2745b45f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -88,7 +88,7 @@ public class LevelChunk extends ChunkAccess {
     private Supplier<ChunkHolder.FullChunkStatus> fullStatus;
     @Nullable
     private LevelChunk.PostLoadProcessor postLoad;
-    private final Int2ObjectMap<GameEventListenerRegistry> gameEventListenerRegistrySections;
+    private final Map<Integer,GameEventListenerRegistry> gameEventListenerRegistrySections;
     private final LevelChunkTicks<Block> blockTicks;
     private final LevelChunkTicks<Fluid> fluidTicks;
 
@@ -114,10 +114,10 @@ public class LevelChunk extends ChunkAccess {
         this.setBlockNibbles(ca.spottedleaf.starlight.common.light.StarLightEngine.getFilledEmptyLight(world));
         this.setSkyNibbles(ca.spottedleaf.starlight.common.light.StarLightEngine.getFilledEmptyLight(world));
         // Paper end - rewrite light engine
-        this.tickersInLevel = Maps.newHashMap();
+        this.tickersInLevel = Maps.newConcurrentMap();
         this.clientLightReady = false;
         this.level = (ServerLevel) world; // CraftBukkit - type
-        this.gameEventListenerRegistrySections = new Int2ObjectOpenHashMap();
+        this.gameEventListenerRegistrySections = Maps.newConcurrentMap();
         Heightmap.Types[] aheightmap_type = Heightmap.Types.values();
         int j = aheightmap_type.length;
 
@@ -1075,10 +1075,8 @@ public class LevelChunk extends ChunkAccess {
 
         for (int i = 0; i < this.postProcessing.length; ++i) {
             if (this.postProcessing[i] != null) {
-                ShortListIterator shortlistiterator = this.postProcessing[i].iterator();
 
-                while (shortlistiterator.hasNext()) {
-                    Short oshort = (Short) shortlistiterator.next();
+                for (Short oshort : this.postProcessing[i]) {
                     BlockPos blockposition = ProtoChunk.unpackOffsetCoordinates(oshort, this.getSectionYFromSectionIndex(i), chunkcoordintpair);
                     BlockState iblockdata = this.getBlockState(blockposition);
                     FluidState fluid = iblockdata.getFluidState();
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityLookup.java b/src/main/java/net/minecraft/world/level/entity/EntityLookup.java
index d45d832232be5017dde53816191c2b1830a0da32..f73f78e2f7c6e3eae66f7608a92854b3246e153d 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityLookup.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityLookup.java
@@ -8,13 +8,15 @@ import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import java.util.Map;
 import java.util.UUID;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import net.minecraft.util.AbortableIterationConsumer;
 import org.slf4j.Logger;
 
 public class EntityLookup<T extends EntityAccess> {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Int2ObjectMap<T> byId = new Int2ObjectLinkedOpenHashMap<>();
-    private final Map<UUID, T> byUuid = Maps.newHashMap();
+    private final Int2ObjectMap<T> byId = Int2ObjectMaps.synchronize(new Int2ObjectLinkedOpenHashMap<>());
+    private final Map<UUID, T> byUuid = Maps.newConcurrentMap();
 
     public <U extends T> void getEntities(EntityTypeTest<T, U> filter, AbortableIterationConsumer<U> consumer) {
         for(T entityAccess : this.byId.values()) {
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index 57fcf3910f45ce371ac2e237b277b1034caaac4e..2a14b665437336aa32ca14fb2137d5bb400e2e42 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -1,49 +1,31 @@
 package net.minecraft.world.level.entity;
 
-import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
-import java.util.function.Consumer;
-import javax.annotation.Nullable;
+import com.google.common.collect.Lists;
 import net.minecraft.world.entity.Entity;
+import java.util.List;
+import java.util.function.Consumer;
 
 public class EntityTickList {
-    public final io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entities = new io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet<>(true); // Paper - rewrite this, always keep this updated - why would we EVER tick an entity that's not ticking? // Pufferfish - private->public
-
-    private void ensureActiveIsNotIterated() {
-        // Paper - replace with better logic, do not delay removals
-
-    }
+    public final List<Entity> entities = Lists.newCopyOnWriteArrayList();
 
     public void add(Entity entity) {
         io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist addition"); // Paper
-        this.ensureActiveIsNotIterated();
-        this.entities.add(entity); // Paper - replace with better logic, do not delay removals/additions
+        this.entities.add(entity);
     }
 
     public void remove(Entity entity) {
         io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist removal"); // Paper
-        this.ensureActiveIsNotIterated();
-        this.entities.remove(entity); // Paper - replace with better logic, do not delay removals/additions
+        this.entities.remove(entity);
     }
 
     public boolean contains(Entity entity) {
-        return this.entities.contains(entity); // Paper - replace with better logic, do not delay removals/additions
+        return this.entities.contains(entity);
     }
 
     public void forEach(Consumer<Entity> action) {
         io.papermc.paper.util.TickThread.ensureTickThread("Asynchronous entity ticklist iteration"); // Paper
-        // Paper start - replace with better logic, do not delay removals/additions
-        // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
-        // (by dfl iterator() is configured to not iterate over new entries)
-        io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entities.iterator();
-        try {
-            while (iterator.hasNext()) {
-                action.accept(iterator.next());
-            }
-        } finally {
-            iterator.finishedIterating();
+        for (Entity entity : this.entities) {
+            action.accept(entity);
         }
-        // Paper end - replace with better logic, do not delay removals/additions
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java b/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
index a77985b2dd7137d8eea03909403fc08e89376d73..6bcbbbfc39432076a3d7714ecc2d05d9112d405c 100644
--- a/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
+++ b/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
@@ -4,12 +4,8 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.mojang.logging.LogUtils;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.IOException;
 import java.io.UncheckedIOException;
@@ -39,15 +35,15 @@ import org.bukkit.craftbukkit.event.CraftEventFactory;
 public class PersistentEntitySectionManager<T extends EntityAccess> implements AutoCloseable {
 
     static final Logger LOGGER = LogUtils.getLogger();
-    final Set<UUID> knownUuids = Sets.newHashSet();
+    final Set<UUID> knownUuids = Sets.newConcurrentHashSet();
     final LevelCallback<T> callbacks;
     public final EntityPersistentStorage<T> permanentStorage;
     private final EntityLookup<T> visibleEntityStorage = new EntityLookup<>();
     final EntitySectionStorage<T> sectionStorage;
     private final LevelEntityGetter<T> entityGetter;
-    private final Long2ObjectMap<Visibility> chunkVisibility = new Long2ObjectOpenHashMap();
-    private final Long2ObjectMap<PersistentEntitySectionManager.ChunkLoadStatus> chunkLoadStatuses = new Long2ObjectOpenHashMap();
-    private final LongSet chunksToUnload = new LongOpenHashSet();
+    private final Long2ObjectMap<Visibility> chunkVisibility = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap());
+    private final Long2ObjectMap<PersistentEntitySectionManager.ChunkLoadStatus> chunkLoadStatuses = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap());
+    private final LongSet chunksToUnload = LongSets.synchronize(new LongOpenHashSet());
     private final Queue<ChunkEntities<T>> loadingInbox = Queues.newConcurrentLinkedQueue();
 
     public PersistentEntitySectionManager(Class<T> entityClass, LevelCallback<T> handler, EntityPersistentStorage<T> dataAccess) {
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
index a8af51a25b0f99c3a64d9150fdfcd6b818aa7581..cd2592552339a79361d2a4e7936731330e15f6fa 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/PathFinder.java
@@ -31,7 +31,7 @@ public class PathFinder {
     }
 
     @Nullable
-    public Path findPath(PathNavigationRegion world, Mob mob, Set<BlockPos> positions, float followRange, int distance, float rangeMultiplier) {
+    public synchronized Path findPath(PathNavigationRegion world, Mob mob, Set<BlockPos> positions, float followRange, int distance, float rangeMultiplier) {
         this.openSet.clear();
         this.nodeEvaluator.prepare(world, mob);
         Node node = this.nodeEvaluator.getStart();
diff --git a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
index 365c3d01a59d117ee9f238b1c1ded645d6b758d3..34fbabc696c0e82b907f4bf7e63b6b92ed89e7e1 100644
--- a/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
+++ b/src/main/java/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
@@ -1,8 +1,10 @@
 package net.minecraft.world.level.pathfinder;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
+import it.unimi.dsi.fastutil.objects.Object2BooleanMaps;
 import it.unimi.dsi.fastutil.objects.Object2BooleanOpenHashMap;
 import java.util.EnumSet;
 import javax.annotation.Nullable;
@@ -33,8 +35,8 @@ public class WalkNodeEvaluator extends NodeEvaluator {
     public static final double SPACE_BETWEEN_WALL_POSTS = 0.5D;
     private static final double DEFAULT_MOB_JUMP_HEIGHT = 1.125D;
     protected float oldWaterCost;
-    private final Long2ObjectMap<BlockPathTypes> pathTypesByPosCache = new Long2ObjectOpenHashMap<>();
-    private final Object2BooleanMap<AABB> collisionCache = new Object2BooleanOpenHashMap<>();
+    private final Long2ObjectMap<BlockPathTypes> pathTypesByPosCache = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>());
+    private final Object2BooleanMap<AABB> collisionCache = Object2BooleanMaps.synchronize(new Object2BooleanOpenHashMap<>());
 
     @Override
     public void prepare(PathNavigationRegion cachedWorld, Mob entity) {
diff --git a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
index b1c594dc6a6b8a6c737b99272acab9e7dbd0ed63..5bb3ef743fd2c0e0ac69e340355acbf49e4c862b 100644
--- a/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
+++ b/src/main/java/net/minecraft/world/level/redstone/CollectingNeighborUpdater.java
@@ -1,9 +1,14 @@
 package net.minecraft.world.level.redstone;
 
+import com.google.common.collect.Lists;
 import com.mojang.logging.LogUtils;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Deque;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.locks.StampedLock;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -16,8 +21,8 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Level level;
     private final int maxChainedNeighborUpdates;
-    private final ArrayDeque<CollectingNeighborUpdater.NeighborUpdates> stack = new ArrayDeque<>();
-    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = new ArrayList<>();
+    private final Deque<NeighborUpdates> stack = new ArrayDeque<>();
+    private final List<CollectingNeighborUpdater.NeighborUpdates> addedThisLayer = Lists.newArrayList();
     private int count = 0;
 
     public CollectingNeighborUpdater(Level world, int maxChainDepth) {
@@ -26,22 +31,22 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
     }
 
     @Override
-    public void shapeUpdate(Direction direction, BlockState neighborState, BlockPos pos, BlockPos neighborPos, int flags, int maxUpdateDepth) {
+    public synchronized void shapeUpdate(Direction direction, BlockState neighborState, BlockPos pos, BlockPos neighborPos, int flags, int maxUpdateDepth) {
         this.addAndRun(pos, new CollectingNeighborUpdater.ShapeUpdate(direction, neighborState, pos.immutable(), neighborPos.immutable(), flags));
     }
 
     @Override
-    public void neighborChanged(BlockPos pos, Block sourceBlock, BlockPos sourcePos) {
+    public synchronized void neighborChanged(BlockPos pos, Block sourceBlock, BlockPos sourcePos) {
         this.addAndRun(pos, new CollectingNeighborUpdater.SimpleNeighborUpdate(pos, sourceBlock, sourcePos.immutable()));
     }
 
     @Override
-    public void neighborChanged(BlockState state, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
+    public synchronized void neighborChanged(BlockState state, BlockPos pos, Block sourceBlock, BlockPos sourcePos, boolean notify) {
         this.addAndRun(pos, new CollectingNeighborUpdater.FullNeighborUpdate(state, pos.immutable(), sourceBlock, sourcePos.immutable(), notify));
     }
 
     @Override
-    public void updateNeighborsAtExceptFromFacing(BlockPos pos, Block sourceBlock, @Nullable Direction except) {
+    public synchronized void updateNeighborsAtExceptFromFacing(BlockPos pos, Block sourceBlock, @Nullable Direction except) {
         this.addAndRun(pos, new CollectingNeighborUpdater.MultiNeighborUpdate(pos.immutable(), sourceBlock, except));
     }
 
@@ -62,20 +67,18 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
         if (!bl) {
             this.runUpdates();
         }
-
     }
 
     private void runUpdates() {
         try {
-            while(!this.stack.isEmpty() || !this.addedThisLayer.isEmpty()) {
-                for(int i = this.addedThisLayer.size() - 1; i >= 0; --i) {
+            while (!this.stack.isEmpty() || !this.addedThisLayer.isEmpty()) {
+                for (int i = this.addedThisLayer.size() - 1; i >= 0; --i) {
                     this.stack.push(this.addedThisLayer.get(i));
                 }
-
                 this.addedThisLayer.clear();
                 CollectingNeighborUpdater.NeighborUpdates neighborUpdates = this.stack.peek();
 
-                while(this.addedThisLayer.isEmpty()) {
+                while (this.addedThisLayer.isEmpty()) {
                     if (!neighborUpdates.runNext(this.level)) {
                         this.stack.pop();
                         break;
@@ -87,7 +90,6 @@ public class CollectingNeighborUpdater implements NeighborUpdater {
             this.addedThisLayer.clear();
             this.count = 0;
         }
-
     }
 
     static record FullNeighborUpdate(BlockState state, BlockPos pos, Block block, BlockPos neighborPos, boolean movedByPiston) implements CollectingNeighborUpdater.NeighborUpdates {
diff --git a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
index ac807277a6b26d140ea9873d17c7aa4fb5fe37b2..367ce55fb9b31f718357a8da522a639848e9dc6a 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelChunkTicks.java
@@ -13,6 +13,8 @@ import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import it.unimi.dsi.fastutil.objects.ObjectSets;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.world.level.ChunkPos;
@@ -29,17 +31,16 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
     private boolean dirty;
     private long lastSaved = Long.MIN_VALUE;
 
-    public boolean isDirty(final long tick) {
+    public synchronized boolean isDirty(final long tick) {
         return this.dirty || (!this.tickQueue.isEmpty() && tick != this.lastSaved);
     }
 
-    public void clearDirty() {
+    public synchronized void clearDirty() {
         this.dirty = false;
     }
     // Paper end - add dirty flag
 
-    public LevelChunkTicks() {
-    }
+    public LevelChunkTicks() {}
 
     public LevelChunkTicks(List<SavedTick<T>> ticks) {
         this.pendingTicks = ticks;
@@ -47,20 +48,19 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
         for(SavedTick<T> savedTick : ticks) {
             this.ticksPerPosition.add(ScheduledTick.probe(savedTick.type(), savedTick.pos()));
         }
-
     }
 
-    public void setOnTickAdded(@Nullable BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> tickConsumer) {
+    public synchronized void setOnTickAdded(@Nullable BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> tickConsumer) {
         this.onTickAdded = tickConsumer;
     }
 
     @Nullable
-    public ScheduledTick<T> peek() {
+    public synchronized ScheduledTick<T> peek() {
         return this.tickQueue.peek();
     }
 
     @Nullable
-    public ScheduledTick<T> poll() {
+    public synchronized ScheduledTick<T> poll() {
         ScheduledTick<T> scheduledTick = this.tickQueue.poll();
         if (scheduledTick != null) {
             this.dirty = true; // Paper - add dirty flag
@@ -71,7 +71,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
     }
 
     @Override
-    public void schedule(ScheduledTick<T> orderedTick) {
+    public synchronized void schedule(ScheduledTick<T> orderedTick) {
         if (this.ticksPerPosition.add(orderedTick)) {
             this.dirty = true; // Paper - add dirty flag
             this.scheduleUnchecked(orderedTick);
@@ -88,11 +88,11 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
     }
 
     @Override
-    public boolean hasScheduledTick(BlockPos pos, T type) {
+    public synchronized boolean hasScheduledTick(BlockPos pos, T type) {
         return this.ticksPerPosition.contains(ScheduledTick.probe(type, pos));
     }
 
-    public void removeIf(Predicate<ScheduledTick<T>> predicate) {
+    public synchronized void removeIf(Predicate<ScheduledTick<T>> predicate) {
         Iterator<ScheduledTick<T>> iterator = this.tickQueue.iterator();
 
         while(iterator.hasNext()) {
@@ -105,17 +105,17 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
 
     }
 
-    public Stream<ScheduledTick<T>> getAll() {
+    public synchronized Stream<ScheduledTick<T>> getAll() {
         return this.tickQueue.stream();
     }
 
     @Override
-    public int count() {
+    public synchronized int count() {
         return this.tickQueue.size() + (this.pendingTicks != null ? this.pendingTicks.size() : 0);
     }
 
     @Override
-    public ListTag save(long l, Function<T, String> function) {
+    public synchronized ListTag save(long l, Function<T, String> function) {
         this.lastSaved = l; // Paper - add dirty system to level ticks
         ListTag listTag = new ListTag();
         if (this.pendingTicks != null) {
@@ -131,7 +131,7 @@ public class LevelChunkTicks<T> implements SerializableTickContainer<T>, TickCon
         return listTag;
     }
 
-    public void unpack(long time) {
+    public synchronized void unpack(long time) {
         if (this.pendingTicks != null) {
             // Paper start - add dirty system to level chunk ticks
             if (this.tickQueue.isEmpty()) {
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index 5dea8414964e0d2d1fb15a6baa27227e9722bfc7..da9fdcce1562ebf5334a7441414a1fecc5d2a791 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -1,24 +1,9 @@
 package net.minecraft.world.ticks;
 
-import it.unimi.dsi.fastutil.longs.Long2LongMap;
-import it.unimi.dsi.fastutil.longs.Long2LongMaps;
-import it.unimi.dsi.fastutil.longs.Long2LongOpenHashMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.List;
-import java.util.LongSummaryStatistics;
-import java.util.PriorityQueue;
-import java.util.Queue;
-import java.util.Set;
-import java.util.function.BiConsumer;
-import java.util.function.LongPredicate;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
+import it.unimi.dsi.fastutil.objects.ObjectSets;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -26,13 +11,18 @@ import net.minecraft.core.Vec3i;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import java.util.*;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.locks.StampedLock;
+import java.util.function.BiConsumer;
+import java.util.function.LongPredicate;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
 
 public class LevelTicks<T> implements LevelTickAccess<T> {
-    private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> {
-        return ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(a.peek(), b.peek());
-    };
+    private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> ScheduledTick.INTRA_TICK_DRAIN_ORDER.compare(a.peek(), b.peek());
     private final LongPredicate tickCheck;
-    private final Supplier<ProfilerFiller> profiler;
     private final Long2ObjectMap<LevelChunkTicks<T>> allContainers = new Long2ObjectOpenHashMap<>();
     private final Long2LongMap nextTickForContainer = Util.make(new Long2LongOpenHashMap(), (map) -> {
         map.defaultReturnValue(Long.MAX_VALUE);
@@ -41,47 +31,60 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     private final Queue<ScheduledTick<T>> toRunThisTick = new ArrayDeque<>();
     private final List<ScheduledTick<T>> alreadyRunThisTick = new ArrayList<>();
     private final Set<ScheduledTick<?>> toRunThisTickSet = new ObjectOpenCustomHashSet<>(ScheduledTick.UNIQUE_TICK_HASH);
+    private final StampedLock ticksLock = new StampedLock(); //Hearse
+
     private final BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>> chunkScheduleUpdater = (chunkTickScheduler, tick) -> {
         if (tick.equals(chunkTickScheduler.peek())) {
             this.updateContainerScheduling(tick);
         }
-
     };
 
     public LevelTicks(LongPredicate tickingFutureReadyPredicate, Supplier<ProfilerFiller> profilerGetter) {
         this.tickCheck = tickingFutureReadyPredicate;
-        this.profiler = profilerGetter;
     }
 
     public void addContainer(ChunkPos pos, LevelChunkTicks<T> scheduler) {
-        long l = pos.toLong();
-        this.allContainers.put(l, scheduler);
-        ScheduledTick<T> scheduledTick = scheduler.peek();
-        if (scheduledTick != null) {
-            this.nextTickForContainer.put(l, scheduledTick.triggerTick());
+        final long stamp = this.ticksLock.writeLock();
+        try {
+            long l = pos.toLong();
+            this.allContainers.put(l, scheduler);
+            ScheduledTick<T> scheduledTick = scheduler.peek();
+            if (scheduledTick != null) {
+                this.nextTickForContainer.put(l, scheduledTick.triggerTick());
+            }
+            scheduler.setOnTickAdded(this.chunkScheduleUpdater);
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
         }
-
-        scheduler.setOnTickAdded(this.chunkScheduleUpdater);
     }
 
     public void removeContainer(ChunkPos pos) {
-        long l = pos.toLong();
-        LevelChunkTicks<T> levelChunkTicks = this.allContainers.remove(l);
-        this.nextTickForContainer.remove(l);
-        if (levelChunkTicks != null) {
-            levelChunkTicks.setOnTickAdded((BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>>)null);
+        final long stamp = this.ticksLock.writeLock();
+        try {
+            long l = pos.toLong();
+            LevelChunkTicks<T> levelChunkTicks = this.allContainers.remove(l);
+            this.nextTickForContainer.remove(l);
+            if (levelChunkTicks != null) {
+                levelChunkTicks.setOnTickAdded((BiConsumer<LevelChunkTicks<T>, ScheduledTick<T>>)null);
+            }
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
         }
-
     }
 
     @Override
     public void schedule(ScheduledTick<T> orderedTick) {
-        long l = ChunkPos.asLong(orderedTick.pos());
-        LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
-        if (levelChunkTicks == null) {
-            Util.pauseInIde(new IllegalStateException("Trying to schedule tick in not loaded position " + orderedTick.pos()));
-        } else {
-            levelChunkTicks.schedule(orderedTick);
+        final long stamp = this.ticksLock.readLock();
+        try{
+            long l = ChunkPos.asLong(orderedTick.pos());
+            LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
+            if (levelChunkTicks == null) {
+                Util.pauseInIde(new IllegalStateException("Trying to schedule tick in not loaded position " + orderedTick.pos()));
+            } else {
+                levelChunkTicks.schedule(orderedTick);
+            }
+        }finally {
+            this.ticksLock.unlockRead(stamp);
         }
     }
 
@@ -105,55 +108,76 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void sortContainersToTick(long time) {
-        ObjectIterator<Long2LongMap.Entry> objectIterator = Long2LongMaps.fastIterator(this.nextTickForContainer);
-
-        while(objectIterator.hasNext()) {
-            Long2LongMap.Entry entry = objectIterator.next();
-            long l = entry.getLongKey();
-            long m = entry.getLongValue();
-            if (m <= time) {
-                LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
-                if (levelChunkTicks == null) {
-                    objectIterator.remove();
-                } else {
-                    ScheduledTick<T> scheduledTick = levelChunkTicks.peek();
-                    if (scheduledTick == null) {
+        final long stamp = this.ticksLock.writeLock();
+        try {
+            ObjectIterator<Long2LongMap.Entry> objectIterator = Long2LongMaps.fastIterator(this.nextTickForContainer);
+            while(objectIterator.hasNext()) {
+                Long2LongMap.Entry entry = objectIterator.next();
+                long l = entry.getLongKey();
+                long m = entry.getLongValue();
+                if (m <= time) {
+                    LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
+                    if (levelChunkTicks == null) {
                         objectIterator.remove();
-                    } else if (scheduledTick.triggerTick() > time) {
-                        entry.setValue(scheduledTick.triggerTick());
-                    } else if (this.tickCheck.test(l)) {
-                        objectIterator.remove();
-                        this.containersToTick.add(levelChunkTicks);
+                    } else {
+                        ScheduledTick<T> scheduledTick = levelChunkTicks.peek();
+                        if (scheduledTick == null) {
+                            objectIterator.remove();
+                        } else if (scheduledTick.triggerTick() > time) {
+                            entry.setValue(scheduledTick.triggerTick());
+                        } else if (this.tickCheck.test(l)) {
+                            objectIterator.remove();
+                            this.containersToTick.add(levelChunkTicks);
+                        }
                     }
                 }
             }
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
         }
-
     }
 
     private void drainContainers(long time, int maxTicks) {
-        LevelChunkTicks<T> levelChunkTicks;
-        while(this.canScheduleMoreTicks(maxTicks) && (levelChunkTicks = this.containersToTick.poll()) != null) {
-            ScheduledTick<T> scheduledTick = levelChunkTicks.poll();
-            this.scheduleForThisTick(scheduledTick);
-            this.drainFromCurrentContainer(this.containersToTick, levelChunkTicks, time, maxTicks);
-            ScheduledTick<T> scheduledTick2 = levelChunkTicks.peek();
-            if (scheduledTick2 != null) {
-                if (scheduledTick2.triggerTick() <= time && this.canScheduleMoreTicks(maxTicks)) {
-                    this.containersToTick.add(levelChunkTicks);
-                } else {
-                    this.updateContainerScheduling(scheduledTick2);
+        final long stamp = this.ticksLock.writeLock();
+        try {
+            LevelChunkTicks<T> levelChunkTicks;
+            while (this.canScheduleMoreTicks(maxTicks) && (levelChunkTicks = this.containersToTick.poll()) != null) {
+                ScheduledTick<T> scheduledTick = levelChunkTicks.poll();
+                this.scheduleForThisTick(scheduledTick);
+                this.drainFromCurrentContainer(this.containersToTick, levelChunkTicks, time, maxTicks);
+                ScheduledTick<T> scheduledTick2 = levelChunkTicks.peek();
+                if (scheduledTick2 != null) {
+                    if (scheduledTick2.triggerTick() <= time && this.canScheduleMoreTicks(maxTicks)) {
+                        this.containersToTick.add(levelChunkTicks);
+                    } else {
+                        this.updateContainerScheduling(scheduledTick2);
+                    }
                 }
             }
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
         }
-
     }
 
     private void rescheduleLeftoverContainers() {
-        for(LevelChunkTicks<T> levelChunkTicks : this.containersToTick) {
-            this.updateContainerScheduling(levelChunkTicks.peek());
+        final List<LevelChunkTicks<T>> cop = new ArrayList<>();
+        long stamp = this.ticksLock.readLock();
+        try {
+            for (LevelChunkTicks<T> levelChunkTicks : this.containersToTick) {
+                cop.add(levelChunkTicks);
+            }
+        }finally {
+            this.ticksLock.unlockRead(stamp);
         }
 
+        stamp = this.ticksLock.writeLock();
+        try {
+            for (LevelChunkTicks<T> levelChunkTicks : cop){
+                this.updateContainerScheduling(levelChunkTicks.peek());
+            }
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
+        }
     }
 
     private void updateContainerScheduling(ScheduledTick<T> tick) {
@@ -187,42 +211,81 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     private void runCollectedTicks(BiConsumer<BlockPos, T> ticker) {
-        while(!this.toRunThisTick.isEmpty()) {
-            ScheduledTick<T> scheduledTick = this.toRunThisTick.poll();
-            if (!this.toRunThisTickSet.isEmpty()) {
-                this.toRunThisTickSet.remove(scheduledTick);
+        ScheduledTick[] cop;
+
+        long stamp = this.ticksLock.writeLock();
+        try {
+            cop = new ScheduledTick[this.toRunThisTick.size()];
+            int counter = 0;
+            while(!this.toRunThisTick.isEmpty()) {
+                ScheduledTick<T> scheduledTick = this.toRunThisTick.poll();
+                if (!this.toRunThisTickSet.isEmpty()) {
+                    this.toRunThisTickSet.remove(scheduledTick);
+                }
+                cop[counter] = scheduledTick;
+                counter++;
             }
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
+        }
 
-            this.alreadyRunThisTick.add(scheduledTick);
+        for (ScheduledTick<T> scheduledTick : cop){
             ticker.accept(scheduledTick.pos(), scheduledTick.type());
         }
 
+        stamp = this.ticksLock.writeLock();
+        try {
+            for (ScheduledTick<T> scheduledTick : cop){
+                this.alreadyRunThisTick.add(scheduledTick);
+            }
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
+        }
     }
 
     private void cleanupAfterTick() {
-        this.toRunThisTick.clear();
-        this.containersToTick.clear();
-        this.alreadyRunThisTick.clear();
-        this.toRunThisTickSet.clear();
+        final long stamp = this.ticksLock.writeLock();
+        try {
+            this.toRunThisTick.clear();
+            this.containersToTick.clear();
+            this.alreadyRunThisTick.clear();
+            this.toRunThisTickSet.clear();
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
+        }
     }
 
     @Override
     public boolean hasScheduledTick(BlockPos pos, T type) {
-        LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(ChunkPos.asLong(pos));
-        return levelChunkTicks != null && levelChunkTicks.hasScheduledTick(pos, type);
+        final long stamp = this.ticksLock.readLock();
+        try {
+            LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(ChunkPos.asLong(pos));
+            return levelChunkTicks != null && levelChunkTicks.hasScheduledTick(pos, type);
+        }finally {
+            this.ticksLock.unlockRead(stamp);
+        }
     }
 
     @Override
     public boolean willTickThisTick(BlockPos pos, T type) {
         this.calculateTickSetIfNeeded();
-        return this.toRunThisTickSet.contains(ScheduledTick.probe(type, pos));
+        final long stamp = this.ticksLock.readLock();
+        try {
+            return this.toRunThisTickSet.contains(ScheduledTick.probe(type, pos));
+        }finally {
+            this.ticksLock.unlockRead(stamp);
+        }
     }
 
     private void calculateTickSetIfNeeded() {
-        if (this.toRunThisTickSet.isEmpty() && !this.toRunThisTick.isEmpty()) {
-            this.toRunThisTickSet.addAll(this.toRunThisTick);
+        final long stamp = this.ticksLock.writeLock();
+        try{
+            if (this.toRunThisTickSet.isEmpty() && !this.toRunThisTick.isEmpty()) {
+                this.toRunThisTickSet.addAll(this.toRunThisTick);
+            }
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
         }
-
     }
 
     private void forContainersInArea(BoundingBox box, LevelTicks.PosAndContainerConsumer<T> visitor) {
@@ -234,7 +297,20 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
         for(int m = i; m <= k; ++m) {
             for(int n = j; n <= l; ++n) {
                 long o = ChunkPos.asLong(m, n);
-                LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(o);
+                LevelChunkTicks<T> levelChunkTicks;
+
+                long stamp = this.ticksLock.tryOptimisticRead();
+                if (this.ticksLock.validate(stamp)){
+                    levelChunkTicks = this.allContainers.get(o);
+                }else{
+                    stamp = this.ticksLock.readLock();
+                    try {
+                        levelChunkTicks = this.allContainers.get(o);
+                    }finally {
+                        this.ticksLock.unlockRead(stamp);
+                    }
+                }
+
                 if (levelChunkTicks != null) {
                     visitor.accept(o, levelChunkTicks);
                 }
@@ -244,24 +320,32 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
     }
 
     public void clearArea(BoundingBox box) {
-        Predicate<ScheduledTick<T>> predicate = (tick) -> {
-            return box.isInside(tick.pos());
-        };
+        Predicate<ScheduledTick<T>> predicate = (tick) -> box.isInside(tick.pos());
         this.forContainersInArea(box, (chunkPos, chunkTickScheduler) -> {
-            ScheduledTick<T> scheduledTick = chunkTickScheduler.peek();
-            chunkTickScheduler.removeIf(predicate);
-            ScheduledTick<T> scheduledTick2 = chunkTickScheduler.peek();
-            if (scheduledTick2 != scheduledTick) {
-                if (scheduledTick2 != null) {
-                    this.updateContainerScheduling(scheduledTick2);
-                } else {
-                    this.nextTickForContainer.remove(chunkPos);
+            final long stamp = this.ticksLock.writeLock();
+            try {
+                ScheduledTick<T> scheduledTick = chunkTickScheduler.peek();
+                chunkTickScheduler.removeIf(predicate);
+                ScheduledTick<T> scheduledTick2 = chunkTickScheduler.peek();
+                if (scheduledTick2 != scheduledTick) {
+                    if (scheduledTick2 != null) {
+                        this.updateContainerScheduling(scheduledTick2);
+                    } else {
+                        this.nextTickForContainer.remove(chunkPos);
+                    }
                 }
+            }finally {
+                this.ticksLock.unlockWrite(stamp);
             }
-
         });
-        this.alreadyRunThisTick.removeIf(predicate);
-        this.toRunThisTick.removeIf(predicate);
+
+        final long stamp = this.ticksLock.writeLock();
+        try {
+            this.alreadyRunThisTick.removeIf(predicate);
+            this.toRunThisTick.removeIf(predicate);
+        }finally {
+            this.ticksLock.unlockWrite(stamp);
+        }
     }
 
     public void copyArea(BoundingBox box, Vec3i offset) {
@@ -269,22 +353,34 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
         Predicate<ScheduledTick<T>> predicate = (tick) -> {
             return box.isInside(tick.pos());
         };
-        this.alreadyRunThisTick.stream().filter(predicate).forEach(list::add);
-        this.toRunThisTick.stream().filter(predicate).forEach(list::add);
-        this.forContainersInArea(box, (chunkPos, chunkTickScheduler) -> {
-            chunkTickScheduler.getAll().filter(predicate).forEach(list::add);
-        });
-        LongSummaryStatistics longSummaryStatistics = list.stream().mapToLong(ScheduledTick::subTickOrder).summaryStatistics();
-        long l = longSummaryStatistics.getMin();
-        long m = longSummaryStatistics.getMax();
-        list.forEach((tick) -> {
-            this.schedule(new ScheduledTick<>(tick.type(), tick.pos().offset(offset), tick.triggerTick(), tick.priority(), tick.subTickOrder() - l + m + 1L));
-        });
+
+        long l;
+        long m;
+
+        final long stamp = this.ticksLock.readLock();
+        try {
+            this.alreadyRunThisTick.stream().filter(predicate).forEach(list::add);
+            this.toRunThisTick.stream().filter(predicate).forEach(list::add);
+            this.forContainersInArea(box, (chunkPos, chunkTickScheduler) -> {
+                chunkTickScheduler.getAll().filter(predicate).forEach(list::add);
+            });
+            LongSummaryStatistics longSummaryStatistics = list.stream().mapToLong(ScheduledTick::subTickOrder).summaryStatistics();
+            l = longSummaryStatistics.getMin();
+            m = longSummaryStatistics.getMax();
+        }finally {
+            this.ticksLock.unlockRead(stamp);
+        }
+        list.forEach((tick) -> this.schedule(new ScheduledTick<>(tick.type(), tick.pos().offset(offset), tick.triggerTick(), tick.priority(), tick.subTickOrder() - l + m + 1L)));
     }
 
     @Override
     public int count() {
-        return this.allContainers.values().stream().mapToInt(TickAccess::count).sum();
+        final long stamp = this.ticksLock.readLock();
+        try {
+            return this.allContainers.values().stream().mapToInt(TickAccess::count).sum();
+        }finally {
+            this.ticksLock.unlockRead(stamp);
+        }
     }
 
     @FunctionalInterface
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index b65c39645aa437fdb1ac745ec18bba11f63f092d..4801feb525881055935a0083dd46f1e656b5a57f 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -2,7 +2,6 @@ package org.bukkit.craftbukkit.event;
 
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
-import com.google.common.collect.Lists;
 import com.mojang.datafixers.util.Either;
 import java.net.InetAddress;
 import java.util.ArrayList;
@@ -57,6 +56,7 @@ import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.EntityHitResult;
 import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
+import org.apache.logging.log4j.LogManager;
 import org.bukkit.Bukkit;
 import org.bukkit.Location; // Paper
 import org.bukkit.Material;
@@ -1062,7 +1062,8 @@ public class CraftEventFactory {
                 cause = DamageCause.CONTACT;
             // Purpur end
             } else {
-                throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.msgId));
+                cause = DamageCause.CUSTOM;
+                LogManager.getLogger().warn(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.msgId));
             }
             EntityDamageEvent event = new EntityDamageByBlockEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions);
             event.setCancelled(cancelled);
@@ -1092,7 +1093,8 @@ public class CraftEventFactory {
             } else if (source == DamageSource.MAGIC) {
                 cause = DamageCause.MAGIC;
             } else {
-                throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager.getHandle(), source.msgId));
+                LogManager.getLogger().error(String.format("Unhandled damage of %s by %s from %s", entity, damager.getHandle(), source.msgId));
+                cause = DamageCause.CUSTOM;
             }
             EntityDamageEvent event = new EntityDamageByEntityEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions, source.isCritical()); // Paper - add critical damage API
             event.setCancelled(cancelled);
@@ -1143,11 +1145,12 @@ public class CraftEventFactory {
         // Purpur end
         }
 
-        if (cause != null) {
-            return CraftEventFactory.callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions, cancelled, source.isCritical()); // Paper - add critical damage API
+        if (cause == null) {
+            LogManager.getLogger().warn(String.format("Unhandled damage of %s from %s", entity, source.msgId));
+            cause = DamageCause.CUSTOM;
         }
-
-        throw new IllegalStateException(String.format("Unhandled damage of %s from %s", entity, source.msgId));
+        
+        return CraftEventFactory.callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions, cancelled, source.isCritical()); // Paper - add critical damage API
     }
 
     @Deprecated // Paper - Add critical damage API
